#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
GPT Exploit Advisor for RedFlow
Advanced AI-powered exploit suggestion engine
"""

import os
import json
import re
import time
import logging
import glob
import subprocess
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
import sys
import markdown
from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel
import yaml

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

# Import required RedFlow components
from redflow.utils.config import Config
from redflow.modules.gpt.openai_client import OpenAIClient

@dataclass
class ExploitInfo:
    """Dataclass to store exploit information"""
    title: str
    path: str
    file_ext: str
    cve: Optional[str] = None
    service: Optional[str] = None
    protocol: Optional[str] = None
    min_version: Optional[str] = None
    max_version: Optional[str] = None
    metasploit_path: Optional[str] = None
    description: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "title": self.title,
            "path": self.path,
            "file_ext": self.file_ext,
            "cve": self.cve,
            "service": self.service,
            "protocol": self.protocol,
            "min_version": self.min_version,
            "max_version": self.max_version,
            "metasploit_path": self.metasploit_path,
            "description": self.description
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ExploitInfo':
        """Create ExploitInfo from dictionary"""
        return cls(
            title=data.get("title", ""),
            path=data.get("path", ""),
            file_ext=data.get("file_ext", ""),
            cve=data.get("cve"),
            service=data.get("service"),
            protocol=data.get("protocol"),
            min_version=data.get("min_version"),
            max_version=data.get("max_version"),
            metasploit_path=data.get("metasploit_path"),
            description=data.get("description")
        )


class ExploitAdvisor:
    """
    GPT-powered exploit advisor for RedFlow
    
    This class handles:
    1. Caching and indexing of local exploit databases
    2. Matching services and versions to appropriate exploits
    3. Using GPT to verify and explain exploits
    4. Generating Metasploit resource scripts
    """
    
    def __init__(self, config: Config, logger: logging.Logger, console=None):
        """
        Initialize GPT Exploit Advisor
        
        Args:
            config: RedFlow configuration
            logger: Logger instance
            console: Rich console instance (optional)
        """
        self.config = config
        self.logger = logger
        self.console = console or Console()
        
        # Initialize OpenAI client with API key
        api_key = config.get_gpt_api_key()
        
        if not api_key:
            self.logger.warning("OpenAI API key not found. Attempting to get key from user.")
            self.console.print("[bold yellow]OpenAI API key not found. GPT Exploit Advisor requires a valid API key.[/bold yellow]")
            
            # Ask the user for an API key
            self.console.print("\n[bold cyan]OpenAI API Key Setup[/bold cyan]")
            self.console.print("[yellow]An OpenAI API key is required for GPT-powered exploit analysis.[/yellow]")
            self.console.print("[yellow]You can get one from https://platform.openai.com/api-keys[/yellow]")
            api_key = self.console.input("[green]Enter your OpenAI API key: [/green]").strip()
            
            if api_key and len(api_key) > 10:
                # Ask if they want to save it
                save_key = self.console.input("[green]Save this API key for future use? (y/n): [/green]").lower()
                if save_key.startswith("y"):
                    key_file = os.path.expanduser('~/.openai_api_key')
                    with open(key_file, 'w') as f:
                        f.write(api_key)
                    self.console.print("[green]API key saved to ~/.openai_api_key[/green]")
                    
                    # Also try to update config.yaml if it exists
                    config_file = os.path.join(os.path.dirname(config.output_dir), "config.yaml")
                    if os.path.exists(config_file):
                        try:
                            with open(config_file, 'r', encoding='utf-8') as f:
                                config_data = yaml.safe_load(f)
                            
                            if config_data and 'gpt' in config_data:
                                config_data['gpt']['api_key'] = api_key
                                with open(config_file, 'w', encoding='utf-8') as f:
                                    yaml.dump(config_data, f, default_flow_style=False)
                                self.console.print("[green]API key also saved to config.yaml[/green]")
                        except Exception as e:
                            self.logger.warning(f"Could not update config.yaml: {e}")
                
                # Set the API key in the config and in environment
                config.set_gpt_api_key(api_key)
                os.environ["OPENAI_API_KEY"] = api_key
            else:
                self.logger.warning("Invalid API key provided. GPT Exploit Advisor will use mock responses.")
                self.console.print("[bold yellow]Invalid API key. GPT Exploit Advisor will use limited mock responses.[/bold yellow]")
                api_key = "mock_api_key"  # Use a placeholder so client initializes
        
        # Pass all GPT settings to OpenAI client
        self.openai_client = OpenAIClient(
            api_key=api_key,
            logger=logger,
            model=config.gpt_settings["model"],
            temperature=config.gpt_settings["temperature"],
            max_tokens=config.gpt_settings["max_tokens"],
            top_p=config.gpt_settings.get("top_p", 1.0),
            frequency_penalty=config.gpt_settings.get("frequency_penalty", 0.0),
            presence_penalty=config.gpt_settings.get("presence_penalty", 0.0)
        )
        
        # Check if the OpenAI client is available
        if not self.openai_client.available:
            self.logger.warning("GPT Exploit Advisor is not available - invalid or missing API key")
            self.console.print("[bold yellow]Note: GPT Exploit Advisor is not available - missing or invalid API key[/bold yellow]")

        # Initialize cache paths and directories
        self.cache_dir = os.path.join(config.output_dir, "cache")
        self.exploits_cache_file = os.path.join(self.cache_dir, "exploits_cache.json")
        
        # Create cache directory if it doesn't exist
        os.makedirs(self.cache_dir, exist_ok=True)
         
        # Set paths for exploitdb and metasploit
        if hasattr(config, 'exploitation'):
            self.exploit_db_path = config.exploitation.get("exploitdb_path", "/usr/share/exploitdb")
        else:
            self.exploit_db_path = "/usr/share/exploitdb"
            self.logger.warning("Exploitation configuration not found, using default paths")
        
        self.metasploit_path = "/usr/share/metasploit-framework/modules/exploits"
        
        # Initialize caches
        self.cached_exploits: List[ExploitInfo] = []
        self.gpt_responses: Dict[str, Any] = {}
        
        # Load or initialize the exploit cache
        self.load_or_build_cache()
    
    def load_or_build_cache(self) -> None:
        """Load cached exploits or build the cache if not available"""
        if os.path.exists(self.exploits_cache_file):
            cache_age = datetime.now() - datetime.fromtimestamp(os.path.getmtime(self.exploits_cache_file))
            
            # If cache is less than 7 days old, load it
            if cache_age < timedelta(days=7):
                self.logger.info("Loading exploit cache from file")
                try:
                    with open(self.exploits_cache_file, 'r') as f:
                        cache_data = json.load(f)
                        self.cached_exploits = [ExploitInfo.from_dict(item) for item in cache_data]
                    
                    self.logger.info(f"Loaded {len(self.cached_exploits)} exploits from cache")
                    return
                except Exception as e:
                    self.logger.warning(f"Failed to load exploit cache: {e}")
        
        # If we get here, we need to build the cache
        self.logger.info("Building exploit cache from local databases")
        self.console.print("[bold yellow]Building exploit database cache. This might take a moment...[/bold yellow]")
        
        # Clear existing cache
        self.cached_exploits = []
        
        # Index ExploitDB
        if os.path.exists(self.exploit_db_path):
            self._index_exploitdb()
        else:
            self.logger.warning(f"ExploitDB not found at {self.exploit_db_path}")
            self.console.print(f"[bold red]Warning:[/bold red] ExploitDB not found at {self.exploit_db_path}")
            
            # Check if searchsploit is installed
            try:
                # Try running searchsploit with -h to check if it's installed
                result = subprocess.run(["searchsploit", "-h"], capture_output=True, text=True)
                if result.returncode != 0:
                    self.console.print("[bold red]Error:[/bold red] searchsploit command not found")
                    self.console.print("[yellow]To install searchsploit on Kali Linux, run:[/yellow]")
                    self.console.print("    sudo apt update && sudo apt install exploitdb")
            except FileNotFoundError:
                self.console.print("[bold red]Error:[/bold red] searchsploit command not found")
                self.console.print("[yellow]To install searchsploit on Kali Linux, run:[/yellow]")
                self.console.print("    sudo apt update && sudo apt install exploitdb")
        
        # Index Metasploit modules
        if os.path.exists(self.metasploit_path):
            self._index_metasploit()
        else:
            self.logger.warning(f"Metasploit framework not found at {self.metasploit_path}")
            self.console.print(f"[bold red]Warning:[/bold red] Metasploit framework not found at {self.metasploit_path}")
            
            # Check if msfconsole is installed
            try:
                # Try running msfconsole with -h to check if it's installed
                result = subprocess.run(["msfconsole", "-h"], capture_output=True, text=True)
                if result.returncode != 0:
                    self.console.print("[bold red]Error:[/bold red] msfconsole command not found")
                    self.console.print("[yellow]To install Metasploit on Kali Linux, run:[/yellow]")
                    self.console.print("    sudo apt update && sudo apt install metasploit-framework")
            except FileNotFoundError:
                self.console.print("[bold red]Error:[/bold red] msfconsole command not found")
                self.console.print("[yellow]To install Metasploit on Kali Linux, run:[/yellow]")
                self.console.print("    sudo apt update && sudo apt install metasploit-framework")
                self.console.print("[yellow]After installation, restart your terminal and try again.[/yellow]")
        
        # Save the cache
        self._save_cache()
        
        self.logger.info(f"Built cache with {len(self.cached_exploits)} exploits")
        self.console.print(f"[bold green]Built exploit cache with {len(self.cached_exploits)} entries[/bold green]")
    
    def _save_cache(self) -> None:
        """Save the current exploit cache to disk"""
        try:
            cache_data = [exploit.to_dict() for exploit in self.cached_exploits]
            with open(self.exploits_cache_file, 'w') as f:
                json.dump(cache_data, f, indent=2)
            self.logger.info(f"Saved {len(self.cached_exploits)} exploits to cache")
        except Exception as e:
            self.logger.error(f"Failed to save exploit cache: {e}")
    
    def _index_exploitdb(self) -> None:
        """Index exploits from ExploitDB"""
        self.logger.info("Indexing ExploitDB exploits")
        
        # Get exploits from FileDiscloser.csv
        csv_path = os.path.join(self.exploit_db_path, "files_exploits.csv")
        if not os.path.exists(csv_path):
            self.logger.warning(f"ExploitDB CSV file not found at {csv_path}")
            return
        
        try:
            # Read the CSV file manually to avoid dependencies
            with open(csv_path, 'r', encoding='utf-8') as f:
                # Skip header
                header = f.readline().strip().split(',')
                
                # Process each line
                for line in f:
                    try:
                        # Split by comma, but respect quotes
                        parts = re.findall(r'(?:[^,"]|"(?:\\.|[^"])*")++', line)
                        parts = [p.strip().strip('"') for p in parts]
                        
                        if len(parts) < 5:
                            continue
                        
                        # Extract information
                        exploit_id = parts[0].strip()
                        file_path = parts[1].strip()
                        title = parts[2].strip()
                        
                        # Full path to the exploit
                        full_path = os.path.join(self.exploit_db_path, file_path)
                        if not os.path.exists(full_path):
                            continue
                        
                        # Extract extension
                        file_ext = os.path.splitext(file_path)[1].lower()
                        
                        # Extract CVE if present
                        cve = None
                        cve_match = re.search(r'CVE-\d{4}-\d{4,}', title, re.IGNORECASE)
                        if cve_match:
                            cve = cve_match.group(0)
                        
                        # Extract service and version information
                        service, min_version, max_version = self._extract_service_info(title)
                        
                        # Create and add exploit info
                        exploit_info = ExploitInfo(
                            title=title,
                            path=full_path,
                            file_ext=file_ext,
                            cve=cve,
                            service=service,
                            min_version=min_version,
                            max_version=max_version
                        )
                        
                        self.cached_exploits.append(exploit_info)
                    except Exception as e:
                        self.logger.debug(f"Error processing exploit line: {e}")
                        continue
        
        except Exception as e:
            self.logger.error(f"Error indexing ExploitDB: {e}")
        
        self.logger.info(f"Indexed {len(self.cached_exploits)} exploits from ExploitDB")
    
    def _index_metasploit(self) -> None:
        """Index exploits from Metasploit Framework"""
        self.logger.info("Indexing Metasploit modules")
        
        # Get all .rb files recursively
        pattern = os.path.join(self.metasploit_path, "**", "*.rb")
        module_files = glob.glob(pattern, recursive=True)
        
        metasploit_count = 0
        
        for file_path in module_files:
            try:
                # Extract module path (relative to exploits directory)
                rel_path = os.path.relpath(file_path, self.metasploit_path)
                module_path = os.path.splitext(rel_path)[0]  # Remove .rb extension
                
                # Read file content to extract information
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Extract name/title
                title_match = re.search(r"['\"]Name['\"].*?['\"](.+?)['\"]", content, re.DOTALL)
                title = title_match.group(1) if title_match else os.path.basename(file_path)
                
                # Extract description
                desc_match = re.search(r"['\"]Description['\"].*?['\"](.+?)['\"]", content, re.DOTALL)
                description = desc_match.group(1) if desc_match else None
                
                # Extract CVE if present
                cve = None
                cve_match = re.search(r'CVE-\d{4}-\d{4,}', content, re.IGNORECASE)
                if cve_match:
                    cve = cve_match.group(0)
                
                # Extract service and version information
                service, min_version, max_version = self._extract_service_info(title)
                
                # Determine protocol from the module path
                protocol = None
                if "/ftp/" in file_path:
                    protocol = "ftp"
                elif "/ssh/" in file_path:
                    protocol = "ssh"
                elif "/http/" in file_path:
                    protocol = "http"
                elif "/smb/" in file_path:
                    protocol = "smb"
                
                # Create metasploit module path
                metasploit_module_path = f"exploit/{module_path}"
                
                # Create and add exploit info
                exploit_info = ExploitInfo(
                    title=title,
                    path=file_path,
                    file_ext=".rb",
                    cve=cve,
                    service=service,
                    protocol=protocol,
                    min_version=min_version,
                    max_version=max_version,
                    metasploit_path=metasploit_module_path,
                    description=description
                )
                
                self.cached_exploits.append(exploit_info)
                metasploit_count += 1
            
            except Exception as e:
                self.logger.debug(f"Error processing Metasploit module {file_path}: {e}")
                continue
        
        self.logger.info(f"Indexed {metasploit_count} modules from Metasploit")
    
    def _extract_service_info(self, title: str) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """
        Extract service name and version information from exploit title
        
        Args:
            title: Exploit title
            
        Returns:
            Tuple of (service, min_version, max_version)
        """
        # Common services to look for
        common_services = [
            "apache", "nginx", "iis", "vsftpd", "proftpd", "openssh", "wordpress",
            "tomcat", "jboss", "weblogic", "drupal", "joomla", "mysql", "postgresql",
            "oracle", "samba", "smb", "windows", "linux", "unix", "macos", "docker",
            "kubernetes", "jenkins", "gitlab", "php", "python", "perl", "ruby", "java"
        ]
        
        service = None
        min_version = None
        max_version = None
        
        # Try to match service name
        for s in common_services:
            if re.search(r'\b' + re.escape(s) + r'\b', title.lower()):
                service = s
                break
        
        # Extract version ranges using various patterns
        
        # Pattern: Apache 2.4.0 - 2.4.49
        range_match = re.search(r'(\d+\.\d+(?:\.\d+)?)\s*[-_~]\s*(\d+\.\d+(?:\.\d+)?)', title)
        if range_match:
            min_version = range_match.group(1)
            max_version = range_match.group(2)
            return service, min_version, max_version
        
        # Pattern: Apache <= 2.4.49
        lte_match = re.search(r'<=\s*(\d+\.\d+(?:\.\d+)?)', title)
        if lte_match:
            max_version = lte_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache < 2.4.50
        lt_match = re.search(r'<\s*(\d+\.\d+(?:\.\d+)?)', title)
        if lt_match:
            # For "Apache < 2.4.50", max version would be 2.4.49
            version_parts = lt_match.group(1).split('.')
            if len(version_parts) >= 3:
                patch = int(version_parts[2]) - 1
                if patch >= 0:
                    max_version = f"{version_parts[0]}.{version_parts[1]}.{patch}"
            else:
                max_version = lt_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache >= 2.4.0
        gte_match = re.search(r'>=\s*(\d+\.\d+(?:\.\d+)?)', title)
        if gte_match:
            min_version = gte_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache > 2.3.9
        gt_match = re.search(r'>\s*(\d+\.\d+(?:\.\d+)?)', title)
        if gt_match:
            # For "Apache > 2.3.9", min version would be 2.4.0 (increment minor)
            version_parts = gt_match.group(1).split('.')
            if len(version_parts) >= 2:
                minor = int(version_parts[1]) + 1
                min_version = f"{version_parts[0]}.{minor}.0"
            else:
                min_version = gt_match.group(1)
            return service, min_version, max_version
        
        # Pattern: Apache 2.4.49
        version_match = re.search(r'\b(\d+\.\d+(?:\.\d+)?)\b', title)
        if version_match:
            exact_version = version_match.group(1)
            # Assuming this is the exact version affected
            min_version = exact_version
            max_version = exact_version
            return service, min_version, max_version
        
        return service, min_version, max_version
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        """
        Compare two version strings
        
        Args:
            version1: First version string
            version2: Second version string
            
        Returns:
            -1 if version1 < version2, 0 if version1 == version2, 1 if version1 > version2
        """
        try:
            v1_parts = list(map(int, version1.split('.')))
            v2_parts = list(map(int, version2.split('.')))
            
            # Pad with zeros if needed
            while len(v1_parts) < len(v2_parts):
                v1_parts.append(0)
            while len(v2_parts) < len(v1_parts):
                v2_parts.append(0)
            
            for i in range(len(v1_parts)):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1
            
            return 0
        except Exception:
            # If we can't parse the versions, just do string comparison
            if version1 < version2:
                return -1
            elif version1 > version2:
                return 1
            else:
                return 0
    
    def _is_version_in_range(self, version: str, min_version: Optional[str], max_version: Optional[str]) -> bool:
        """
        Check if a version is within a specified range
        
        Args:
            version: Version to check
            min_version: Minimum version (inclusive) or None
            max_version: Maximum version (inclusive) or None
            
        Returns:
            True if version is in range, False otherwise
        """
        if not version:
            return False
        
        # If no range specified, assume match
        if not min_version and not max_version:
            return True
        
        # Check minimum version
        if min_version and self._compare_versions(version, min_version) < 0:
            return False
        
        # Check maximum version
        if max_version and self._compare_versions(version, max_version) > 0:
            return False
        
        return True
    
    def find_exploits_for_service(self, service_name: str, version: Optional[str] = None) -> List[ExploitInfo]:
        """
        Find exploits for a given service and version
        
        Args:
            service_name: Name of the service (e.g., 'ftp', 'ssh')
            version: Optional version string
            
        Returns:
            List of matching ExploitInfo objects
        """
        self.logger.info(f"Searching for exploits for {service_name} {version if version else ''}")
        
        # First attempt: exact match with version if provided
        exact_matches = []
        version_matches = []
        service_matches = []
        
        for exploit in self.cached_exploits:
            # Skip if service doesn't match at all
            if exploit.service and service_name.lower() not in exploit.service.lower():
                continue
                
            # Check if we have an exact service name match
            is_exact_service_match = (exploit.service and exploit.service.lower() == service_name.lower())
            
            # If version is provided, check version constraints
            if version and exploit.min_version:
                # Try exact version match first
                if (is_exact_service_match and 
                    ((exploit.min_version and exploit.min_version == version) or
                     (exploit.max_version and exploit.max_version == version))):
                    exact_matches.append(exploit)
                # Then try version range match
                elif (is_exact_service_match and 
                      self._is_version_in_range(version, exploit.min_version, exploit.max_version)):
                    version_matches.append(exploit)
                # Otherwise, if service matches but version doesn't
                elif is_exact_service_match:
                    service_matches.append(exploit)
            # If no version constraints, just match on service
            elif is_exact_service_match:
                service_matches.append(exploit)
            # Partial service match as last resort
            else:
                service_matches.append(exploit)
                
        # Combine results with priority ordering
        results = exact_matches + version_matches + service_matches
        self.logger.info(f"Found {len(results)} potential exploits for {service_name} {version if version else ''}")
        
        return results[:self.config.exploitation.get("max_exploits_to_suggest", 10)]
    
    def generate_gpt_prompt(self, exploit: ExploitInfo, service_name: str, version: str) -> str:
        """
        Generate a prompt for GPT to analyze an exploit
        
        Args:
            exploit: ExploitInfo object
            service_name: Service name
            version: Service version
            
        Returns:
            Prompt string for GPT
        """
        prompt = """
You are a penetration testing expert with over 20 years of experience. Professionals from around the world rely on your advice.

A junior penetration tester came to you with an urgent case — he needs to earn $2 million to pay for his mother's medical treatment, and this engagement is his only shot. He's stuck and needs your expertise.

"""
        
        prompt += f"Detected {service_name} {version} on a server.\n"
        prompt += "Found exploit:\n"
        prompt += f"- Title: {exploit.title}\n"
        prompt += f"- Path: {exploit.path}\n"
        
        if exploit.cve:
            prompt += f"- CVE: {exploit.cve}\n"
        
        prompt += f"- File type: {exploit.file_ext}\n"
        
        if exploit.metasploit_path:
            prompt += f"- Metasploit path: {exploit.metasploit_path}\n"
        
        prompt += f"\nDoes this exploit apply to {service_name} {version}?\n"
        prompt += "If yes, explain how to run it and what to expect. Be clear, concise, and actionable — lives depend on it.\n"
        
        # Add hints based on file extension
        if exploit.file_ext == ".py":
            prompt += "\nIf it's a Python script, include exact command to run it.\n"
        elif exploit.file_ext == ".rb" and exploit.metasploit_path:
            prompt += "\nIf it's a Metasploit module, provide the commands for msfconsole including required options.\n"
        elif exploit.file_ext == ".c":
            prompt += "\nIf it's a C source file, explain how to compile and run it.\n"
        elif exploit.file_ext == ".sh":
            prompt += "\nIf it's a shell script, explain how to run it.\n"
        
        prompt += "\nFinally, format your answer in Markdown with sections for Vulnerability Assessment, Execution Instructions, and Expected Outcome."
        
        return prompt
    
    def analyze_exploit_with_gpt(self, exploit: ExploitInfo, service_name: str, version: str) -> Optional[str]:
        """
        Send exploit information to GPT for analysis
        
        Args:
            exploit: ExploitInfo object
            service_name: Service name
            version: Service version
            
        Returns:
            GPT's response or None if API key not provided or error occurs
        """
        if not self.openai_client.available:
            self.logger.warning("Cannot get exploit advice - OpenAI client not available")
        # Check if GPT API key is available
        api_key = self.config.get_gpt_api_key()
        if not api_key:
            self.logger.warning("GPT API key not found. Skipping GPT analysis.")
            self.console.print("[bold yellow]Warning: GPT API key not found. Skipping GPT analysis.[/bold yellow]")
            self.console.print("[bold yellow]Add your API key to config.yaml under gpt.api_key to enable GPT analysis.[/bold yellow]")
            return None
        
        # Generate cache key for this query
        cache_key = f"{service_name}_{version}_{exploit.path}"
        
        # Check if response is already cached
        if cache_key in self.gpt_responses:
            self.logger.info(f"Using cached GPT response for {cache_key}")
            return self.gpt_responses[cache_key]
        
        # Generate prompt
        prompt = self.generate_gpt_prompt(exploit, service_name, version)
        
        try:
            self.logger.info(f"Sending request to GPT API for analysis of {exploit.title}")
            self.console.print(f"[bold cyan]Requesting GPT analysis for {exploit.title}...[/bold cyan]")
            
            # Send the prompt to OpenAI client
            response = self.openai_client.get_completion(prompt, service_name)
            
            if not response:
                self.logger.warning("No response from GPT API")
                self.console.print("[bold yellow]Note: No response from GPT API[/bold yellow]")
                
                # Use a simple mock response as fallback
                response = f"""
# Vulnerability Analysis

## Objective
- **Service**: {service_name} {version}
- **Exploit**: {exploit.title}

## Analysis
No analysis available from GPT API. This is a mock response.

# Execution Instructions

1. Navigate to the exploit directory:
   ```bash
   cd {os.path.dirname(exploit.path)}
   ```

2. Run the exploit (adjust for file type):
   ```bash
   # For Python
   python3 {os.path.basename(exploit.path)} -t <TARGET_IP> -p <PORT>
   # Or
   msfconsole -q                                # For Metasploit
   use {exploit.metasploit_path or 'path/to/module'}
   # And so on
   ```
"""
            
            # Cache the response
            self.gpt_responses[cache_key] = response
            
            self.logger.info(f"Received GPT analysis for {exploit.title}")
            return response
            
        except Exception as e:
            self.logger.error(f"Error in GPT API request: {e}")
            self.console.print(f"[bold red]Error in GPT API request: {e}[/bold red]")
            return None
    
    def generate_metasploit_resource(self, metasploit_path: str, target_ip: str, port: int) -> str:
        """
        Generate a Metasploit resource script
        
        Args:
            metasploit_path: Path to Metasploit module
            target_ip: Target IP address
            port: Target port
            
        Returns:
            Path to generated resource script
        """
        self.logger.info(f"Generating Metasploit resource script for {metasploit_path}")
        
        # Create resource script content
        script_content = f"""use {metasploit_path}
set RHOSTS {target_ip}
set RPORT {port}
set LHOST 0.0.0.0
set LPORT 4444
show options
"""
        
        # Create a temporary file
        resource_file = os.path.join(self.config.output_dir, f"msf_{int(time.time())}.rc")
        
        try:
            with open(resource_file, 'w') as f:
                f.write(script_content)
            
            self.logger.info(f"Created Metasploit resource script at {resource_file}")
            return resource_file
        
        except Exception as e:
            self.logger.error(f"Error creating Metasploit resource script: {e}")
            return ""
    
    def run_metasploit_resource(self, resource_file: str) -> bool:
        """
        Run a Metasploit resource script
        
        Args:
            resource_file: Path to resource script
            
        Returns:
            True if successful, False otherwise
        """
        self.logger.info(f"Running Metasploit resource script {resource_file}")
        self.console.print(f"[bold cyan]Running Metasploit with resource script {resource_file}...[/bold cyan]")
        
        try:
            cmd = ["msfconsole", "-q", "-r", resource_file]
            
            # Run msfconsole
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )
            
            # Print output in real-time
            while True:
                output = process.stdout.readline()
                if not output and process.poll() is not None:
                    break
                if output:
                    self.console.print(output.strip())
            
            return process.returncode == 0
            
        except Exception as e:
            self.logger.error(f"Error running Metasploit: {e}")
            self.console.print(f"[bold red]Error running Metasploit: {e}[/bold red]")
            return False
    
    def interactive_exploit_advisor(self, target_services: List[Dict[str, Any]]) -> None:
        """
        Interactive exploit advisor for discovered services
        
        Args:
            target_services: List of discovered services with name, version, and port
        """
        self.logger.info("Starting interactive exploit advisor")
        self.console.print("\n[bold blue]======== RedFlow + GPT Exploit Advisor ========[/bold blue]")
        self.console.print("[bold blue]This feature suggests exploits based on detected services[/bold blue]\n")
        
        # Check if there are any services
        if not target_services:
            self.console.print("[bold yellow]No services detected. Run a scan first.[/bold yellow]")
            return
        
        # Import ExploitSuggester here to avoid circular imports
        from redflow.modules.gpt.exploit_suggester import ExploitSuggester
        
        # Convert services to target_info format expected by ExploitSuggester
        target_info = {
            "ip": target_services[0].get("target", "127.0.0.1"),
            "domain": target_services[0].get("hostname", ""),
            "ports": {}
        }
        
        # Convert services list to dictionary format for ExploitSuggester
        for service in target_services:
            port = service.get("port", "0")
            target_info["ports"][port] = {
                "service": service.get("name", "unknown"),
                "version": service.get("version", "unknown"),
                "state": "open"
            }
        
        # Create ExploitSuggester and run the suggestion process
        suggester = ExploitSuggester(self.config, self.logger)
        suggested_exploits = suggester.suggest_exploits(target_info)
        
        # Ask if user wants detailed analysis for any exploit
        if suggested_exploits:
            self.console.print("\n[bold cyan]Do you want a detailed analysis for a specific exploit? (y/n)[/bold cyan]")
            detailed_analysis = input("> ").strip().lower().startswith("y")
            
            if detailed_analysis:
                # First, create a flat list of all services and exploits
                all_exploits = []
                for service_port, exploits in suggested_exploits.items():
                    service_name, port = service_port.split(":")
                    for exploit in exploits:
                        if "gpt_analysis" in exploit:
                            exploit_with_service = exploit.copy()
                            exploit_with_service["service"] = service_name
                            exploit_with_service["port"] = port
                            all_exploits.append(exploit_with_service)
                
                # Display available exploits with GPT analysis
                if all_exploits:
                    self.console.print("\n[bold green]Exploits with available GPT analysis:[/bold green]")
                    for i, exploit in enumerate(all_exploits, 1):
                        self.console.print(f"[{i}] {exploit['title']} ({exploit['service']} on port {exploit['port']})")
                    
                    # Ask user to select an exploit
                    self.console.print("\n[bold cyan]Select exploit for detailed analysis (number):[/bold cyan]")
                    exploit_selection = input("> ").strip()
                    
                    try:
                        exploit_idx = int(exploit_selection) - 1
                        if 0 <= exploit_idx < len(all_exploits):
                            selected_exploit = all_exploits[exploit_idx]
                            
                            # Show detailed analysis
                            self.console.print("\n[bold green]Detailed Analysis:[/bold green]")
                            self.display_advice(selected_exploit["gpt_analysis"])
                            
                            # Ask about running exploit with Metasploit
                            if selected_exploit.get("metasploit_path"):
                                self.console.print("\n[bold cyan]Do you want to run this exploit with Metasploit? (y/n)[/bold cyan]")
                                use_msf = input("> ").strip().lower().startswith("y")
                                
                                if use_msf:
                                    # Generate and run Metasploit resource script
                                    resource_file = self.generate_metasploit_resource(
                                        selected_exploit["metasploit_path"],
                                        target_info["ip"],
                                        int(selected_exploit["port"])
                                    )
                                    if resource_file:
                                        self.run_metasploit_resource(resource_file)
                        else:
                            self.console.print("[bold red]Invalid selection.[/bold red]")
                    except ValueError:
                        self.console.print("[bold red]Invalid selection.[/bold red]")
                else:
                    self.console.print("[bold yellow]No exploits with GPT analysis available.[/bold yellow]")
        
        self.console.print("\n[bold blue]GPT Exploit Advisor session completed[/bold blue]")
    
    def display_advice(self, advice: str) -> None:
        """
        Display formatted exploit advice from GPT
        
        Args:
            advice: Markdown-formatted advice from GPT
        """
        self.logger.info("Displaying exploit advice")
        
        try:
            # Convert markdown to rich markdown
            md = Markdown(advice)
            
            # Display in a nice panel
            self.console.print(
                Panel(
                    md,
                    title="[bold blue]GPT Vulnerability Analysis[/bold blue]",
                    border_style="blue",
                    expand=False
                )
            )
        except Exception as e:
            self.logger.error(f"Error displaying advice: {e}")
            # Fallback to plain text if markdown fails
            self.console.print("\n[bold blue]GPT Vulnerability Analysis:[/bold blue]")
            self.console.print(advice) 