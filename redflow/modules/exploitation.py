"""
Module for identifying and potentially exploiting vulnerabilities
"""

import os
import re
import json
import time
import shutil
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
from rich.table import Table

from redflow.utils.logger import get_module_logger
from redflow.utils.helpers import run_tool


class Exploitation:
    """Class for identifying and exploiting vulnerabilities // מחלקה לזיהוי וניצול פגיעויות"""
    
    def __init__(self, config, logger, console):
        """
        Initialize exploitation module
        // אתחול מודול הניצול
        
        Args:
            config: Configuration object
            logger: Logger instance
            console: Console instance
        """
        self.config = config
        self.console = console
        self.logger = get_module_logger("Exploitation", logger)
        self.target = config.target
        self.results = {
            "vulnerabilities": [],
            "exploits": [],
            "credentials": []
        }
    
    def run(self, scan_results):
        """
        Run vulnerability identification and exploitation based on previous scan results
        // הפעלת זיהוי פגיעויות וניצולן בהתאם לתוצאות סריקה קודמות
        
        Args:
            scan_results: Results from previous scanning stages
            
        Returns:
            Exploitation results
        """
        self.logger.info(f"Starting vulnerability analysis for {self.target}")
        self.scan_results = scan_results  # Store for later use
        
        # Create progress display
        with Progress(
            SpinnerColumn(),
            TextColumn("[bold blue]{task.description}"),
            BarColumn(),
            TimeElapsedColumn(),
            console=self.console
        ) as progress:
            # Analyze vulnerabilities from nmap results
            if "active_recon" in scan_results and "nmap_vulns" in scan_results["active_recon"]:
                nmap_task = progress.add_task("[cyan]Analyzing vulnerabilities identified by Nmap...", total=1)
                self._analyze_nmap_vulns(scan_results["active_recon"]["nmap_vulns"])
                progress.update(nmap_task, completed=1)
            
            # Check for vulnerabilities in Web services
            if "enumeration" in scan_results and "web" in scan_results["enumeration"]:
                web_task = progress.add_task("[cyan]Checking for Web service vulnerabilities...", total=1)
                self._analyze_web_vulnerabilities(scan_results["enumeration"]["web"])
                progress.update(web_task, completed=1)
            
            # Check for vulnerabilities in FTP
            if "enumeration" in scan_results and "ftp" in scan_results["enumeration"]:
                ftp_task = progress.add_task("[cyan]Checking for FTP service vulnerabilities...", total=1)
                self._analyze_ftp_vulnerabilities(scan_results["enumeration"]["ftp"])
                progress.update(ftp_task, completed=1)
            
            # Check for vulnerabilities in SMB
            if "enumeration" in scan_results and "smb" in scan_results["enumeration"]:
                smb_task = progress.add_task("[cyan]Checking for SMB service vulnerabilities...", total=1)
                self._analyze_smb_vulnerabilities(scan_results["enumeration"]["smb"])
                progress.update(smb_task, completed=1)
            
            # Attempt basic brute force on services
            brute_task = progress.add_task("[cyan]Performing basic brute force attempts...", total=1)
            self._perform_basic_bruteforce(scan_results)
            progress.update(brute_task, completed=1)
            
            # Search for potential exploits
            if self.results["vulnerabilities"]:
                exploit_task = progress.add_task("[cyan]Searching for potential exploits...", total=1)
                self._find_potential_exploits()
                progress.update(exploit_task, completed=1)
        
        # After all analyses are completed
        self._show_results_summary()
        
        return self.results
    
    def _analyze_nmap_vulns(self, nmap_vulns):
        """
        Analyze vulnerabilities identified by Nmap
        // ניתוח פגיעויות שזוהו על ידי Nmap
        
        Args:
            nmap_vulns: List of vulnerabilities from nmap results
        """
        self.logger.info(f"Analyzing vulnerabilities identified by Nmap for {self.target}")
        
        for vuln in nmap_vulns:
            # Convert vulnerability data to a uniform format
            vulnerability = {
                "name": vuln.get("script", "Unknown"),
                "description": vuln.get("details", ""),
                "service": vuln.get("service", "unknown"),
                "port": vuln.get("port", "0"),
                "severity": vuln.get("severity", "MEDIUM"),
                "source": "nmap",
                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            # Add vulnerability to the list
            self.results["vulnerabilities"].append(vulnerability)
            
            self.logger.info(f"Identified vulnerability: {vulnerability['name']} in service {vulnerability['service']} (port {vulnerability['port']})")
    
    def _analyze_web_vulnerabilities(self, web_results):
        """
        Analyze vulnerabilities in Web services
        // ניתוח פגיעויות בשירותי Web
        
        Args:
            web_results: Web enumeration results
        """
        self.logger.info(f"Checking for Web service vulnerabilities for {self.target}")
        
        # If the result is a list, iterate through it
        if isinstance(web_results, list):
            for web_service in web_results:
                port = web_service.get("port", 80)
                protocol = web_service.get("protocol", "http")
                target_url = f"{protocol}://{self.target}:{port}/"
                
                # Check for common vulnerabilities
                self._check_common_web_vulns(target_url, port)
        else:
            # If the result is a single dictionary
            port = web_results.get("port", 80)
            protocol = web_results.get("protocol", "http")
            target_url = f"{protocol}://{self.target}:{port}/"
            
            # Check for common vulnerabilities
            self._check_common_web_vulns(target_url, port)
    
    def _check_common_web_vulns(self, target_url, port):
        """
        Check for common website vulnerabilities
        // בדיקת פגיעויות נפוצות באתר
        
        Args:
            target_url: Website URL
            port: Port number
        """
        # Basic SQL Injection check
        output_file = self.config.get_output_file(f"sqlmap_{port}", "txt")
        
        # Only basic checks without deep exploitation
        cmd = [
            "sqlmap", 
            "--url", f"{target_url}", 
            "--batch", 
            "--level", "1", 
            "--risk", "1",
            "--output-dir", os.path.dirname(output_file)
        ]
        
        self.logger.debug(f"Checking SQL Injection on {target_url}")
        
        # Run only if the tool is available
        if self._is_tool_available("sqlmap"):
            result = run_tool(cmd, timeout=300)
            
            if result["returncode"] == 0:
                # Check if vulnerabilities were found
                if "is vulnerable" in result["stdout"]:
                    vulnerability = {
                        "name": "SQL Injection",
                        "description": "Website vulnerable to SQL injection",
                        "service": "http",
                        "port": str(port),
                        "severity": "HIGH",
                        "source": "sqlmap",
                        "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                    }
                    
                    self.results["vulnerabilities"].append(vulnerability)
                    self.logger.warning(f"SQL Injection vulnerability found at {target_url}")
        
        # Basic XSS check
        output_file = self.config.get_output_file(f"xss_{port}", "txt")
        
        # Run only if the tool is available
        if self._is_tool_available("xsser"):
            cmd = ["xsser", "--url", target_url, "--auto"]
            
            self.logger.debug(f"Checking XSS on {target_url}")
            
            result = run_tool(cmd, output_file=output_file, timeout=300)
            
            if result["returncode"] == 0:
                # Check if vulnerabilities were found
                if "XSS FOUND" in result["stdout"]:
                    vulnerability = {
                        "name": "Cross-Site Scripting (XSS)",
                        "description": "Website vulnerable to script injection",
                        "service": "http",
                        "port": str(port),
                        "severity": "MEDIUM",
                        "source": "xsser",
                        "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                    }
                    
                    self.results["vulnerabilities"].append(vulnerability)
                    self.logger.warning(f"XSS vulnerability found at {target_url}")
    
    def _analyze_ftp_vulnerabilities(self, ftp_results):
        """
        Analyze vulnerabilities in FTP services
        // ניתוח פגיעויות בשירותי FTP
        
        Args:
            ftp_results: FTP enumeration results
        """
        self.logger.info(f"Checking for FTP service vulnerabilities for {self.target}")
        
        # Check for anonymous access
        if ftp_results.get("anonymous_access", False):
            vulnerability = {
                "name": "Anonymous FTP Access",
                "description": "FTP server allows anonymous access",
                "service": "ftp",
                "port": str(ftp_results.get("port", 21)),
                "severity": "MEDIUM",
                "source": "enumeration",
                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            self.results["vulnerabilities"].append(vulnerability)
            self.logger.warning(f"Anonymous FTP access enabled on port {ftp_results.get('port', 21)}")
    
    def _analyze_smb_vulnerabilities(self, smb_results):
        """
        Analyze vulnerabilities in SMB services
        // ניתוח פגיעויות בשירותי SMB
        
        Args:
            smb_results: SMB enumeration results
        """
        self.logger.info(f"Checking for SMB service vulnerabilities for {self.target}")
        
        # Check for common share vulnerabilities
        if smb_results.get("shares"):
            # Check for shares accessible without authentication
            for share in smb_results.get("shares", []):
                if "IPC$" not in share:  # Skip the standard IPC$
                    output_file = self.config.get_output_file(f"smb_share_{share}", "txt")
                    
                    cmd = ["smbclient", f"//{self.target}/{share}", "-N", "-c", "ls"]
                    
                    result = run_tool(cmd, output_file=output_file)
                    
                    if result["returncode"] == 0 and "NT_STATUS_ACCESS_DENIED" not in result["stdout"]:
                        vulnerability = {
                            "name": f"Anonymous SMB Share Access: {share}",
                            "description": f"Share {share} is accessible without authentication",
                            "service": "smb",
                            "port": str(smb_results.get("port", 445)),
                            "severity": "MEDIUM",
                            "source": "smbclient",
                            "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                        }
                        
                        self.results["vulnerabilities"].append(vulnerability)
                        self.logger.warning(f"Anonymous access to SMB share {share}")
        
        # Check for known vulnerabilities like EternalBlue
        port = smb_results.get("port", 445)
        output_file = self.config.get_output_file(f"smb_vulns_{port}", "txt")
        
        cmd = ["nmap", "--script", "smb-vuln*", "-p", str(port), self.target, "-oN", output_file]
        
        result = run_tool(cmd)
        
        if result["returncode"] == 0:
            # Parse results to identify vulnerabilities
            for line in result["stdout"].splitlines():
                # Search for vulnerability information
                if "VULNERABLE" in line:
                    vuln_match = re.search(r"smb-vuln-([a-zA-Z0-9-]+)", line)
                    if vuln_match:
                        vuln_name = vuln_match.group(1)
                        
                        # Set severity based on vulnerability type
                        severity = "MEDIUM"
                        if "ms17-010" in vuln_name:  # EternalBlue
                            severity = "CRITICAL"
                        
                        vulnerability = {
                            "name": f"SMB Vulnerability: {vuln_name}",
                            "description": f"SMB server vulnerable to {vuln_name}",
                            "service": "smb",
                            "port": str(port),
                            "severity": severity,
                            "source": "nmap",
                            "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                        }
                        
                        self.results["vulnerabilities"].append(vulnerability)
                        self.logger.warning(f"Identified SMB vulnerability: {vuln_name}")
    
    def _perform_basic_bruteforce(self, scan_results):
        """
        Perform basic brute force attempts on identified services
        // ביצוע ניסיונות פריצה בסיסיים לשירותים שזוהו
        
        Args:
            scan_results: Results from previous scanning stages
        """
        self.logger.info(f"Performing basic brute force attempts for {self.target}")
        
        # Try with Hydra, if installed
        if not self._is_tool_available("hydra"):
            self.logger.warning("Hydra tool not found, skipping brute force attempts")
            return
        
        # Try to brute force SSH if identified
        if "enumeration" in scan_results and "ssh" in scan_results["enumeration"]:
            ssh_info = scan_results["enumeration"]["ssh"]
            if "auth_methods" in ssh_info and "password" in ssh_info["auth_methods"]:
                port = ssh_info.get("port", 22)
                
                # Run hydra with a limited list of users and passwords for demonstration
                output_file = self.config.get_output_file(f"hydra_ssh_{port}", "txt")
                
                # Limited brute force attempt with very common users and passwords
                user_list = self.config.wordlist_paths.get("usernames", "")
                pass_list = self.config.wordlist_paths.get("rockyou", "")
                
                if not os.path.exists(user_list) or not os.path.exists(pass_list):
                    self.logger.warning("Suitable wordlists not found for brute force attempt")
                    return
                
                cmd = [
                    "hydra", 
                    "-L", user_list, 
                    "-P", pass_list, 
                    "-f", 
                    "-t", "4",
                    "-o", output_file,
                    f"{self.target}", 
                    "ssh"
                ]
                
                self.logger.debug(f"Attempting to brute force SSH on port {port}")
                
                result = run_tool(cmd, timeout=300)  # Limited runtime
                
                if result["returncode"] == 0:
                    # Check if credentials were found
                    if "password found" in result["stdout"].lower():
                        # Extract the username and password
                        cred_match = re.search(r"login:\s+(\S+)\s+password:\s+(\S+)", result["stdout"])
                        if cred_match:
                            username = cred_match.group(1)
                            password = cred_match.group(2)
                            
                            credential = {
                                "service": "ssh",
                                "port": str(port),
                                "username": username,
                                "password": password,
                                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                            }
                            
                            self.results["credentials"].append(credential)
                            
                            vulnerability = {
                                "name": "Weak SSH Credentials",
                                "description": f"Found weak credentials for SSH service: {username}/{password}",
                                "service": "ssh",
                                "port": str(port),
                                "severity": "HIGH",
                                "source": "hydra",
                                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                            }
                            
                            self.results["vulnerabilities"].append(vulnerability)
                            self.logger.warning(f"Found weak SSH credentials: {username}/{password}")
    
    def _find_potential_exploits(self):
        """
        Search for potential exploit mechanisms for identified vulnerabilities
        // חיפוש מנגנוני ניצול פוטנציאליים עבור הפגיעויות שזוהו
        """
        self.logger.info(f"Searching for potential exploits for {self.target}")
        
        # For each vulnerability, try to find an exploit
        for vuln in self.results["vulnerabilities"]:
            vuln_name = vuln["name"]
            
            # Search in searchsploit if installed
            if self._is_tool_available("searchsploit"):
                output_file = self.config.get_output_file(f"searchsploit_{vuln_name.replace(' ', '_')}", "txt")
                
                # Clean the string for safe search
                search_term = re.sub(r'[^a-zA-Z0-9\s-]', '', vuln_name)
                
                cmd = ["searchsploit", "--colour", search_term]
                
                result = run_tool(cmd, output_file=output_file)
                
                if result["returncode"] == 0:
                    # Check if results were found
                    exploit_lines = []
                    for line in result["stdout"].splitlines():
                        if "|" in line and "Exploit Title" not in line:
                            exploit_lines.append(line.strip())
                    
                    if exploit_lines:
                        # Create a list of potential exploits
                        for exploit_line in exploit_lines[:3]:  # Take only first 3 for demonstration
                            exploit_parts = exploit_line.split("|")
                            if len(exploit_parts) >= 2:
                                exploit_title = exploit_parts[0].strip()
                                exploit_path = exploit_parts[1].strip() if len(exploit_parts) > 1 else ""
                                
                                exploit = {
                                    "name": exploit_title,
                                    "path": exploit_path,
                                    "vulnerability": vuln_name,
                                    "service": vuln["service"],
                                    "port": vuln["port"],
                                    "source": "searchsploit"
                                }
                                
                                self.results["exploits"].append(exploit)
                                self.logger.info(f"Found potential exploit: {exploit_title} for {vuln_name}")
        
        # Find exploits for discovered services using the enhanced searchsploit functionality
        if hasattr(self, 'enumeration') and self.enumeration:
            self._find_service_exploits()
        else:
            from redflow.modules.enumeration import Enumeration
            self.enumeration = Enumeration(self.config, self.logger, self.console)
            self._find_service_exploits()
    
    def _find_service_exploits(self):
        """
        Search for exploits for specific services based on version information
        // חיפוש מנגנוני ניצול עבור שירותים ספציפיים בהתבסס על מידע גרסה
        """
        self.logger.info(f"Searching for service-specific exploits for {self.target}")
        
        if not hasattr(self, 'scan_results') or not self.scan_results:
            self.logger.warning("No scan results available for service exploit search")
            return
        
        if "discovered_services" in self.scan_results:
            discovered_services = self.scan_results["discovered_services"]
            
            for service in discovered_services:
                service_name = service.get("name", "").lower()
                product = service.get("product", "").lower()
                version = service.get("version", "")
                
                # Try to find a more specific product name to search for
                search_name = product if product else service_name
                
                # Skip if we don't have enough information
                if not search_name or not version:
                    continue
                
                self.logger.info(f"Searching exploits for {search_name} {version}")
                
                # Use the enhanced searchsploit functionality
                try:
                    search_results = self.enumeration.find_vulnerabilities_with_searchsploit(search_name, version)
                    
                    # Process results
                    if search_results and "vulnerabilities" in search_results:
                        for vuln in search_results["vulnerabilities"]:
                            exploit = {
                                "name": vuln.get("title", "Unknown exploit"),
                                "path": vuln.get("path", ""),
                                "vulnerability": f"{search_name} {version} exploitation",
                                "service": service_name,
                                "port": service.get("port", ""),
                                "source": "searchsploit"
                            }
                            
                            self.results["exploits"].append(exploit)
                            self.logger.info(f"Found potential exploit: {exploit['name']} for {search_name} {version}")
                except Exception as e:
                    self.logger.error(f"Error searching exploits for {search_name} {version}: {str(e)}")
    
    def interactive_exploit_launcher(self):
        """
        Interactive menu to browse and launch discovered exploits
        """
        self.console.print("\n[bold cyan]Interactive Exploit Launcher[/bold cyan]")
        
        # Check if we have scan results available
        if not self.results or "potential_exploits" not in self.results or not self.results["potential_exploits"]:
            self.console.print("[yellow]No potential exploits found in scan results. Running exploit discovery...[/yellow]")
            self._find_potential_exploits()
            self._find_service_exploits()
        
        # Group exploits by service type
        exploits_by_service = {}
        for exploit in self.results.get("potential_exploits", []):
            service = exploit.get("service", "Unknown")
            if service not in exploits_by_service:
                exploits_by_service[service] = []
            exploits_by_service[service].append(exploit)
        
        # Display available services
        if not exploits_by_service:
            self.console.print("[yellow]No potential exploits found. Would you like to search manually?[/yellow] (y/n)")
            choice = input("> ").strip().lower()
            
            if choice in ['y', 'yes']:
                # Let user specify service and version
                self.console.print("[cyan]Enter service name (e.g., vsftpd):[/cyan]")
                service_name = input("> ").strip()
                
                self.console.print("[cyan]Enter version (or leave blank if unknown):[/cyan]")
                version = input("> ").strip()
                
                # Use enumeration module to search for exploits
                if hasattr(self, 'target') and self.target:
                    # Create Enumeration instance if needed
                    if not hasattr(self, '_enumeration'):
                        from redflow.modules.enumeration import Enumeration
                        self._enumeration = Enumeration(self.config, self.logger, self.console)
                    
                    # Launch exploit menu
                    self._enumeration.interactive_exploit_menu("manual", service_name, version, self.target)
                else:
                    self.console.print("[red]Target not specified. Please run a scan first or specify a target.[/red]")
            
            return
        
        self.console.print("\n[bold green]Available services with potential exploits:[/bold green]")
        services = list(exploits_by_service.keys())
        
        for i, service in enumerate(services, 1):
            exploit_count = len(exploits_by_service[service])
            self.console.print(f"[cyan]{i}.[/cyan] {service} ({exploit_count} exploit{'s' if exploit_count != 1 else ''})")
        
        # Ask user to select a service
        self.console.print("\n[yellow]Select a service to exploit (number) or 'm' for manual search:[/yellow]")
        selection = input("> ").strip().lower()
        
        if selection == 'm':
            # Manual search option
            self.console.print("[cyan]Enter service name (e.g., vsftpd):[/cyan]")
            service_name = input("> ").strip()
            
            self.console.print("[cyan]Enter version (or leave blank if unknown):[/cyan]")
            version = input("> ").strip()
            
            # Use enumeration module to search for exploits
            if hasattr(self, 'target') and self.target:
                # Create Enumeration instance if needed
                if not hasattr(self, '_enumeration'):
                    from redflow.modules.enumeration import Enumeration
                    self._enumeration = Enumeration(self.config, self.logger, self.console)
                
                # Launch exploit menu
                self._enumeration.interactive_exploit_menu("manual", service_name, version, self.target)
            else:
                self.console.print("[red]Target not specified. Please run a scan first or specify a target.[/red]")
            
            return
        
        try:
            if selection.isdigit() and 1 <= int(selection) <= len(services):
                selected_service = services[int(selection) - 1]
                exploits = exploits_by_service[selected_service]
                
                # Show exploits for selected service
                self.console.print(f"\n[bold green]Available exploits for {selected_service}:[/bold green]")
                
                for i, exploit in enumerate(exploits, 1):
                    self.console.print(f"[cyan]{i}.[/cyan] {exploit.get('name', 'Unknown')} - {exploit.get('description', 'No description')}")
                
                # Ask user to select an exploit
                self.console.print("\n[yellow]Select an exploit to use (number) or press Enter to go back:[/yellow]")
                exploit_selection = input("> ").strip()
                
                if exploit_selection.isdigit() and 1 <= int(exploit_selection) <= len(exploits):
                    selected_exploit = exploits[int(exploit_selection) - 1]
                    
                    # Show exploit details
                    self.console.print(f"\n[bold green]Selected Exploit: {selected_exploit.get('name', 'Unknown')}[/bold green]")
                    if 'description' in selected_exploit:
                        self.console.print(f"[white]Description: {selected_exploit['description']}[/white]")
                    if 'reference' in selected_exploit:
                        self.console.print(f"[white]Reference: {selected_exploit['reference']}[/white]")
                    
                    # Handle exploit execution
                    if 'path' in selected_exploit:
                        # Use enumeration module to prepare and run exploit
                        if not hasattr(self, '_enumeration'):
                            from redflow.modules.enumeration import Enumeration
                            self._enumeration = Enumeration(self.config, self.logger, self.console)
                        
                        # Get target and version information
                        target = self.target if hasattr(self, 'target') else selected_exploit.get('target')
                        service_name = selected_exploit.get('service', 'unknown')
                        version = selected_exploit.get('version', '')
                        
                        if target:
                            exploit_path = selected_exploit['path']
                            
                            # Pass to enumeration module for exploit preparation
                            exploit_info = self._enumeration.prepare_exploit(exploit_path, target)
                            
                            if exploit_info:
                                self._enumeration.display_exploit_instructions(exploit_info, target)
                                
                                # Ask if user wants to run exploit
                                self.console.print("\n[yellow]Would you like to run this exploit now? (y/n)[/yellow]")
                                run_choice = input("> ").strip().lower()
                                
                                if run_choice in ['y', 'yes']:
                                    try:
                                        self.console.print(f"[bold yellow]Running exploit: {exploit_info['command']}[/bold yellow]")
                                        
                                        # Handle different exploit types
                                        import subprocess
                                        if exploit_info['type'] == 'python':
                                            process = subprocess.Popen(exploit_info['command'], shell=True)
                                            process.wait()
                                        elif exploit_info['type'] == 'ruby':
                                            process = subprocess.Popen(exploit_info['command'], shell=True)
                                            process.wait()
                                        elif exploit_info['type'] == 'php':
                                            process = subprocess.Popen(exploit_info['command'], shell=True)
                                            process.wait()
                                        elif exploit_info['type'] == 'c':
                                            # Compile and run C exploit
                                            compile_cmd = f"gcc {exploit_info['local_path']} -o {exploit_info['local_path']}.exe"
                                            run_cmd = f"{exploit_info['local_path']}.exe {' '.join(exploit_info['args'])}"
                                            
                                            self.console.print(f"[cyan]Compiling: {compile_cmd}[/cyan]")
                                            compile_process = subprocess.Popen(compile_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                                            stdout, stderr = compile_process.communicate()
                                            
                                            if compile_process.returncode == 0:
                                                self.console.print("[green]Compilation successful.[/green]")
                                                self.console.print(f"[cyan]Running: {run_cmd}[/cyan]")
                                                run_process = subprocess.Popen(run_cmd, shell=True)
                                                run_process.wait()
                                            else:
                                                self.console.print(f"[red]Compilation error: {stderr.decode('utf-8', errors='ignore')}[/red]")
                                        else:
                                            # For all other file types, run the command directly
                                            process = subprocess.Popen(exploit_info['command'], shell=True)
                                            process.wait()
                                    except Exception as e:
                                        self.console.print(f"[red]Error running exploit: {str(e)}[/red]")
                        else:
                            self.console.print("[red]Target not specified. Cannot run exploit.[/red]")
                    else:
                        self.console.print("[yellow]No exploit path available. Cannot run this exploit.[/yellow]")
                        
                        # If we have a reference, display it
                        if 'reference' in selected_exploit:
                            self.console.print(f"[cyan]You can find more information at: {selected_exploit['reference']}[/cyan]")
                
                # After exploit execution or cancellation, ask if user wants to continue
                self.console.print("\n[yellow]Would you like to select another service? (y/n)[/yellow]")
                continue_choice = input("> ").strip().lower()
                
                if continue_choice in ['y', 'yes']:
                    # Recursive call to restart from service selection
                    self.interactive_exploit_launcher()
            
            else:
                self.console.print("[yellow]Invalid selection. Exiting exploit launcher.[/yellow]")
        
        except Exception as e:
            self.console.print(f"[red]Error in exploit launcher: {str(e)}[/red]")
            self.logger.error(f"Error in exploit launcher: {str(e)}")
    
    def _is_tool_available(self, tool_name):
        """
        Check if a tool is available in the system
        // בדיקה האם כלי זמין במערכת
        
        Args:
            tool_name: Name of the tool to check
            
        Returns:
            Boolean: Whether the tool is available
        """
        return shutil.which(tool_name) is not None if 'shutil' in globals() else os.system(f"which {tool_name} > /dev/null") == 0
    
    def _show_results_summary(self):
        """
        Display exploitation results summary
        // הצגת סיכום תוצאות הניצול
        """
        self.console.print("\n[bold green]Vulnerability Analysis Summary:[/bold green]")
        
        # Display vulnerabilities
        if self.results["vulnerabilities"]:
            vuln_table = Table(title="Identified Vulnerabilities")
            vuln_table.add_column("Service", style="cyan")
            vuln_table.add_column("Port", style="cyan")
            vuln_table.add_column("Vulnerability", style="red")
            vuln_table.add_column("Severity", style="yellow")
            
            for vuln in self.results["vulnerabilities"]:
                severity_style = "yellow"
                if vuln["severity"] == "HIGH":
                    severity_style = "red"
                elif vuln["severity"] == "CRITICAL":
                    severity_style = "red bold"
                
                vuln_table.add_row(
                    vuln["service"],
                    vuln["port"],
                    vuln["name"],
                    f"[{severity_style}]{vuln['severity']}[/{severity_style}]"
                )
            
            self.console.print(vuln_table)
        else:
            self.console.print("[yellow]No vulnerabilities identified[/yellow]")
        
        # Display credentials
        if self.results["credentials"]:
            cred_table = Table(title="Exposed Credentials")
            cred_table.add_column("Service", style="cyan")
            cred_table.add_column("Port", style="cyan")
            cred_table.add_column("Username", style="green")
            cred_table.add_column("Password", style="red")
            
            for cred in self.results["credentials"]:
                cred_table.add_row(
                    cred["service"],
                    cred["port"],
                    cred["username"],
                    cred["password"]
                )
            
            self.console.print(cred_table)
        
        # Display exploits
        if self.results["exploits"]:
            exploit_table = Table(title="Potential Exploits")
            exploit_table.add_column("Vulnerability", style="yellow")
            exploit_table.add_column("Exploit Name", style="green")
            exploit_table.add_column("Location", style="cyan")
            
            for exploit in self.results["exploits"]:
                exploit_table.add_row(
                    exploit["vulnerability"],
                    exploit["name"],
                    exploit["path"]
                )
            
            self.console.print(exploit_table)
        
        self.console.print("")  # Extra space 

    def prepare_exploit(self, exploit_path, target):
        """
        Prepare and run an exploit against the target
        // הכנה והרצת אקספלויט נגד המטרה
        
        Args:
            exploit_path: Path to the exploit
            target: Target IP or domain
            
        Returns:
            Boolean: Whether the exploit was successful
        """
        self.logger.info(f"Preparing to run exploit: {exploit_path} against {target}")
        
        # Check if the exploit file exists
        if not os.path.exists(exploit_path):
            self.logger.error(f"Exploit file does not exist: {exploit_path}")
            self.console.print(f"[bold red]Error:[/bold red] Exploit file does not exist: {exploit_path}")
            return False
        
        # Create exploit directory
        exploits_dir = os.path.join(self.config.output_dir, "exploits")
        if not os.path.exists(exploits_dir):
            os.makedirs(exploits_dir)
        
        # Copy the exploit to our directory
        exploit_name = os.path.basename(exploit_path)
        dest_path = os.path.join(exploits_dir, exploit_name)
        try:
            shutil.copy2(exploit_path, dest_path)
            self.logger.info(f"Copied exploit to: {dest_path}")
        except Exception as e:
            self.logger.error(f"Failed to copy exploit: {e}")
            self.console.print(f"[bold red]Error:[/bold red] Failed to copy exploit: {e}")
            return False
        
        # Check if the exploit is a metasploit module
        if "/usr/share/metasploit-framework/" in exploit_path:
            return self._handle_metasploit_exploit(exploit_path, target)
        
        # Make the exploit executable
        try:
            os.chmod(dest_path, 0o755)  # rwx r-x r-x
            self.logger.info(f"Made exploit executable: {dest_path}")
        except Exception as e:
            self.logger.error(f"Failed to make exploit executable: {e}")
            self.console.print(f"[bold red]Error:[/bold red] Failed to make exploit executable: {e}")
            return False
        
        # Check file type and attempt to run if it's a script
        try:
            with open(dest_path, 'rb') as f:
                content = f.read(512)  # Read first 512 bytes to determine file type
        except Exception as e:
            self.logger.error(f"Failed to read exploit file: {e}")
            self.console.print(f"[bold red]Error:[/bold red] Failed to read exploit file: {e}")
            return False
        
        # Don't try to execute binary files directly
        if self._is_binary(content):
            self.logger.info(f"Exploit appears to be a binary file. Manual execution required.")
            self.console.print(f"[bold yellow]Note:[/bold yellow] Exploit appears to be a binary file. Manual execution required.")
            return False
        
        # Try to determine the appropriate interpreter
        interpreter = None
        if content.startswith(b'#!/usr/bin/env python') or content.startswith(b'#!/usr/bin/python'):
            interpreter = "python"
        elif content.startswith(b'#!/usr/bin/env ruby') or content.startswith(b'#!/usr/bin/ruby'):
            interpreter = "ruby"
        elif content.startswith(b'#!/usr/bin/env perl') or content.startswith(b'#!/usr/bin/perl'):
            interpreter = "perl"
        elif content.startswith(b'#!/bin/bash') or content.startswith(b'#!/bin/sh'):
            interpreter = "bash"
        
        # Run the exploit with appropriate interpreter
        if interpreter:
            cmd = [interpreter, dest_path]
        else:
            cmd = [dest_path]
        
        # Add target parameter if it looks like the exploit might accept it
        if b"target" in content or b"TARGET" in content or b"host" in content or b"HOST" in content:
            cmd.append(target)
        
        self.logger.info(f"Running exploit: {' '.join(cmd)}")
        self.console.print(f"[bold green]Running exploit:[/bold green] {' '.join(cmd)}")
        
        # First attempt to run the exploit
        try:
            result = run_tool(cmd, timeout=300)
            self.logger.info(f"Exploit output: {result['stdout']}")
            
            if result["returncode"] != 0:
                self.logger.warning(f"Exploit may have failed. Return code: {result['returncode']}")
                self.console.print(f"[bold yellow]Warning:[/bold yellow] Exploit may have failed. Return code: {result['returncode']}")
                
                # Second attempt if the first one failed
                self.logger.info("Attempting to run the exploit a second time...")
                self.console.print("[bold yellow]Retry:[/bold yellow] Attempting to run the exploit a second time...")
                result = run_tool(cmd, timeout=300)
                self.logger.info(f"Second attempt output: {result['stdout']}")
                
                if result["returncode"] != 0:
                    self.logger.error(f"Exploit failed on second attempt. Return code: {result['returncode']}")
                    self.console.print(f"[bold red]Error:[/bold red] Exploit failed on second attempt.")
                    return False
                else:
                    self.logger.info("Exploit succeeded on second attempt")
                    self.console.print("[bold green]Success:[/bold green] Exploit succeeded on second attempt")
                    return True
            else:
                self.logger.info("Exploit executed successfully")
                self.console.print("[bold green]Success:[/bold green] Exploit executed successfully")
                return True
        
        except Exception as e:
            self.logger.error(f"Error running exploit: {e}")
            self.console.print(f"[bold red]Error:[/bold red] Error running exploit: {e}")
            return False 

    def _handle_metasploit_exploit(self, exploit_path, target):
        """
        Handle Metasploit framework exploits
        // טיפול באקספלויטים של Metasploit
        
        Args:
            exploit_path: Path to Metasploit exploit
            target: Target IP or domain
            
        Returns:
            Boolean: Whether exploitation was successful
        """
        self.logger.info(f"Handling Metasploit exploit: {exploit_path} for target {target}")
        
        # Extract the module path from the exploit path
        module_path = self._extract_metasploit_path(exploit_path)
        if not module_path:
            self.logger.error("Could not extract Metasploit module path")
            self.console.print("[bold red]Error:[/bold red] Could not extract Metasploit module path")
            return False
        
        self.logger.info(f"Extracted Metasploit module: {module_path}")
        self.console.print(f"[bold green]Using Metasploit module:[/bold green] {module_path}")
        
        # Attempt to run the exploit using msfconsole
        commands = [
            f"use {module_path}",
            f"set RHOSTS {target}",
            "check",
            "run"
        ]
        
        # Build the msfconsole command
        msfconsole_cmd = ["msfconsole", "-q", "-x", "; ".join(commands)]
        
        self.logger.info(f"Running Metasploit command: {' '.join(msfconsole_cmd)}")
        self.console.print(f"[bold blue]Running exploit via Metasploit...[/bold blue]")
        
        # First attempt
        try:
            self.console.print("[cyan]First attempt: Running Metasploit exploit...[/cyan]")
            result = run_tool(msfconsole_cmd, timeout=300)  # 5 minutes timeout for first attempt
            
            # Log the output
            self.logger.info(f"Metasploit output (first attempt): {result['stdout']}")
            self.console.print(result["stdout"])
            
            # Check if the exploit was successful
            if "Exploit completed, but no session was created" in result["stdout"]:
                self.logger.warning("First attempt: Exploit completed but no session was created")
                self.console.print("[yellow]First attempt: Exploit completed but no session was created[/yellow]")
                success = False
            elif "Exploit failed" in result["stdout"]:
                self.logger.warning("First attempt: Exploit failed")
                self.console.print("[yellow]First attempt: Exploit failed[/yellow]")
                success = False
            elif "Exploit completed successfully" in result["stdout"] or "Meterpreter session" in result["stdout"] or "Command shell session" in result["stdout"]:
                self.logger.info("First attempt: Exploit completed successfully")
                self.console.print("[green]First attempt: Exploit completed successfully[/green]")
                return True
            else:
                # If we can't determine success, assume it failed
                self.logger.warning("First attempt: Could not determine if exploit was successful, assuming failure")
                self.console.print("[yellow]First attempt: Could not determine if exploit was successful, retrying...[/yellow]")
                success = False
            
            # If first attempt was not successful, try again
            if not success:
                self.logger.info("Attempting to run the exploit a second time...")
                self.console.print("\n[bold yellow]Attempting to run the exploit a second time...[/bold yellow]")
                
                # Add a delay before second attempt
                import time
                time.sleep(5)  # 5 seconds delay
                
                # Slightly modify the commands for the second attempt - add additional options
                commands = [
                    f"use {module_path}",
                    f"set RHOSTS {target}",
                    "set ForceExploit true",  # Force the exploit to run even if the check fails
                    "set VERBOSE true",       # Increase verbosity
                    "run"
                ]
                
                # Build the msfconsole command
                msfconsole_cmd = ["msfconsole", "-q", "-x", "; ".join(commands)]
                
                # Second attempt with longer timeout
                try:
                    self.console.print("[cyan]Second attempt: Running Metasploit exploit with modified settings...[/cyan]")
                    result = run_tool(msfconsole_cmd, timeout=420)  # 7 minutes timeout for second attempt
                    
                    # Log the output
                    self.logger.info(f"Metasploit output (second attempt): {result['stdout']}")
                    self.console.print(result["stdout"])
                    
                    # Check if the exploit was successful on second attempt
                    if "Exploit completed, but no session was created" in result["stdout"]:
                        self.logger.warning("Second attempt: Exploit completed but no session was created")
                        self.console.print("[yellow]Second attempt: Exploit completed but no session was created[/yellow]")
                        
                        # Provide suggestions for manual exploitation
                        self.console.print("\n[bold cyan]Suggestions for manual exploitation:[/bold cyan]")
                        self.console.print("1. Run the following command in your terminal:")
                        self.console.print(f"[white]msfconsole -q -x \"use {module_path}; set RHOSTS {target}; show options; run\"[/white]")
                        self.console.print("2. Check target accessibility and network connectivity")
                        self.console.print("3. Try adjusting exploit options manually")
                        
                        return False
                    elif "Exploit failed" in result["stdout"]:
                        self.logger.warning("Second attempt: Exploit failed")
                        self.console.print("[yellow]Second attempt: Exploit failed[/yellow]")
                        return False
                    elif "Exploit completed successfully" in result["stdout"] or "Meterpreter session" in result["stdout"] or "Command shell session" in result["stdout"]:
                        self.logger.info("Second attempt: Exploit completed successfully")
                        self.console.print("[green]Second attempt: Exploit completed successfully[/green]")
                        return True
                    else:
                        self.logger.warning("Second attempt: Could not determine if exploit was successful")
                        self.console.print("[yellow]Second attempt: Could not determine if exploit was successful[/yellow]")
                        return False
                except Exception as e:
                    self.logger.error(f"Error during second exploit attempt: {e}")
                    self.console.print(f"[bold red]Error during second exploit attempt:[/bold red] {e}")
                    return False
        except Exception as e:
            self.logger.error(f"Error running Metasploit exploit: {e}")
            self.console.print(f"[bold red]Error:[/bold red] {e}")
            return False
        
        return False 