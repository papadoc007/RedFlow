"""
Module for identifying and potentially exploiting vulnerabilities
"""

import os
import re
import json
import time
import shutil
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
from rich.table import Table

from redflow.utils.logger import get_module_logger
from redflow.utils.helpers import run_tool


class Exploitation:
    """Class for identifying and exploiting vulnerabilities // מחלקה לזיהוי וניצול פגיעויות"""
    
    def __init__(self, config, logger, console):
        """
        Initialize exploitation module
        // אתחול מודול הניצול
        
        Args:
            config: Configuration object
            logger: Logger instance
            console: Console instance
        """
        self.config = config
        self.console = console
        self.logger = get_module_logger("Exploitation", logger)
        self.target = config.target
        self.results = {
            "vulnerabilities": [],
            "exploits": [],
            "credentials": []
        }
    
    def run(self, scan_results):
        """
        Run vulnerability identification and exploitation based on previous scan results
        // הפעלת זיהוי פגיעויות וניצולן בהתאם לתוצאות סריקה קודמות
        
        Args:
            scan_results: Results from previous scanning stages
            
        Returns:
            Exploitation results
        """
        self.logger.info(f"Starting vulnerability analysis for {self.target}")
        self.scan_results = scan_results  # Store for later use
        
        # Create progress display
        with Progress(
            SpinnerColumn(),
            TextColumn("[bold blue]{task.description}"),
            BarColumn(),
            TimeElapsedColumn(),
            console=self.console
        ) as progress:
            # Analyze vulnerabilities from nmap results
            if "active_recon" in scan_results and "nmap_vulns" in scan_results["active_recon"]:
                nmap_task = progress.add_task("[cyan]Analyzing vulnerabilities identified by Nmap...", total=1)
                self._analyze_nmap_vulns(scan_results["active_recon"]["nmap_vulns"])
                progress.update(nmap_task, completed=1)
            
            # Check for vulnerabilities in Web services
            if "enumeration" in scan_results and "web" in scan_results["enumeration"]:
                web_task = progress.add_task("[cyan]Checking for Web service vulnerabilities...", total=1)
                self._analyze_web_vulnerabilities(scan_results["enumeration"]["web"])
                progress.update(web_task, completed=1)
            
            # Check for vulnerabilities in FTP
            if "enumeration" in scan_results and "ftp" in scan_results["enumeration"]:
                ftp_task = progress.add_task("[cyan]Checking for FTP service vulnerabilities...", total=1)
                self._analyze_ftp_vulnerabilities(scan_results["enumeration"]["ftp"])
                progress.update(ftp_task, completed=1)
            
            # Check for vulnerabilities in SMB
            if "enumeration" in scan_results and "smb" in scan_results["enumeration"]:
                smb_task = progress.add_task("[cyan]Checking for SMB service vulnerabilities...", total=1)
                self._analyze_smb_vulnerabilities(scan_results["enumeration"]["smb"])
                progress.update(smb_task, completed=1)
            
            # Attempt basic brute force on services
            brute_task = progress.add_task("[cyan]Performing basic brute force attempts...", total=1)
            self._perform_basic_bruteforce(scan_results)
            progress.update(brute_task, completed=1)
            
            # Search for potential exploits
            if self.results["vulnerabilities"]:
                exploit_task = progress.add_task("[cyan]Searching for potential exploits...", total=1)
                self._find_potential_exploits()
                progress.update(exploit_task, completed=1)
        
        # After all analyses are completed
        self._show_results_summary()
        
        return self.results
    
    def _analyze_nmap_vulns(self, nmap_vulns):
        """
        Analyze vulnerabilities identified by Nmap
        // ניתוח פגיעויות שזוהו על ידי Nmap
        
        Args:
            nmap_vulns: List of vulnerabilities from nmap results
        """
        self.logger.info(f"Analyzing vulnerabilities identified by Nmap for {self.target}")
        
        for vuln in nmap_vulns:
            # Convert vulnerability data to a uniform format
            vulnerability = {
                "name": vuln.get("script", "Unknown"),
                "description": vuln.get("details", ""),
                "service": vuln.get("service", "unknown"),
                "port": vuln.get("port", "0"),
                "severity": vuln.get("severity", "MEDIUM"),
                "source": "nmap",
                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            # Add vulnerability to the list
            self.results["vulnerabilities"].append(vulnerability)
            
            self.logger.info(f"Identified vulnerability: {vulnerability['name']} in service {vulnerability['service']} (port {vulnerability['port']})")
    
    def _analyze_web_vulnerabilities(self, web_results):
        """
        Analyze vulnerabilities in Web services
        // ניתוח פגיעויות בשירותי Web
        
        Args:
            web_results: Web enumeration results
        """
        self.logger.info(f"Checking for Web service vulnerabilities for {self.target}")
        
        # If the result is a list, iterate through it
        if isinstance(web_results, list):
            for web_service in web_results:
                port = web_service.get("port", 80)
                protocol = web_service.get("protocol", "http")
                target_url = f"{protocol}://{self.target}:{port}/"
                
                # Check for common vulnerabilities
                self._check_common_web_vulns(target_url, port)
        else:
            # If the result is a single dictionary
            port = web_results.get("port", 80)
            protocol = web_results.get("protocol", "http")
            target_url = f"{protocol}://{self.target}:{port}/"
            
            # Check for common vulnerabilities
            self._check_common_web_vulns(target_url, port)
    
    def _check_common_web_vulns(self, target_url, port):
        """
        Check for common website vulnerabilities
        // בדיקת פגיעויות נפוצות באתר
        
        Args:
            target_url: Website URL
            port: Port number
        """
        # Basic SQL Injection check
        output_file = self.config.get_output_file(f"sqlmap_{port}", "txt")
        
        # Only basic checks without deep exploitation
        cmd = [
            "sqlmap", 
            "--url", f"{target_url}", 
            "--batch", 
            "--level", "1", 
            "--risk", "1",
            "--output-dir", os.path.dirname(output_file)
        ]
        
        self.logger.debug(f"Checking SQL Injection on {target_url}")
        
        # Run only if the tool is available
        if self._is_tool_available("sqlmap"):
            result = run_tool(cmd, timeout=300)
            
            if result["returncode"] == 0:
                # Check if vulnerabilities were found
                if "is vulnerable" in result["stdout"]:
                    vulnerability = {
                        "name": "SQL Injection",
                        "description": "Website vulnerable to SQL injection",
                        "service": "http",
                        "port": str(port),
                        "severity": "HIGH",
                        "source": "sqlmap",
                        "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                    }
                    
                    self.results["vulnerabilities"].append(vulnerability)
                    self.logger.warning(f"SQL Injection vulnerability found at {target_url}")
        
        # Basic XSS check
        output_file = self.config.get_output_file(f"xss_{port}", "txt")
        
        # Run only if the tool is available
        if self._is_tool_available("xsser"):
            cmd = ["xsser", "--url", target_url, "--auto"]
            
            self.logger.debug(f"Checking XSS on {target_url}")
            
            result = run_tool(cmd, output_file=output_file, timeout=300)
            
            if result["returncode"] == 0:
                # Check if vulnerabilities were found
                if "XSS FOUND" in result["stdout"]:
                    vulnerability = {
                        "name": "Cross-Site Scripting (XSS)",
                        "description": "Website vulnerable to script injection",
                        "service": "http",
                        "port": str(port),
                        "severity": "MEDIUM",
                        "source": "xsser",
                        "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                    }
                    
                    self.results["vulnerabilities"].append(vulnerability)
                    self.logger.warning(f"XSS vulnerability found at {target_url}")
    
    def _analyze_ftp_vulnerabilities(self, ftp_results):
        """
        Analyze vulnerabilities in FTP services
        // ניתוח פגיעויות בשירותי FTP
        
        Args:
            ftp_results: FTP enumeration results
        """
        self.logger.info(f"Checking for FTP service vulnerabilities for {self.target}")
        
        # Check for anonymous access
        if ftp_results.get("anonymous_access", False):
            vulnerability = {
                "name": "Anonymous FTP Access",
                "description": "FTP server allows anonymous access",
                "service": "ftp",
                "port": str(ftp_results.get("port", 21)),
                "severity": "MEDIUM",
                "source": "enumeration",
                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            self.results["vulnerabilities"].append(vulnerability)
            self.logger.warning(f"Anonymous FTP access enabled on port {ftp_results.get('port', 21)}")
    
    def _analyze_smb_vulnerabilities(self, smb_results):
        """
        Analyze vulnerabilities in SMB services
        // ניתוח פגיעויות בשירותי SMB
        
        Args:
            smb_results: SMB enumeration results
        """
        self.logger.info(f"Checking for SMB service vulnerabilities for {self.target}")
        
        # Check for common share vulnerabilities
        if smb_results.get("shares"):
            # Check for shares accessible without authentication
            for share in smb_results.get("shares", []):
                if "IPC$" not in share:  # Skip the standard IPC$
                    output_file = self.config.get_output_file(f"smb_share_{share}", "txt")
                    
                    cmd = ["smbclient", f"//{self.target}/{share}", "-N", "-c", "ls"]
                    
                    result = run_tool(cmd, output_file=output_file)
                    
                    if result["returncode"] == 0 and "NT_STATUS_ACCESS_DENIED" not in result["stdout"]:
                        vulnerability = {
                            "name": f"Anonymous SMB Share Access: {share}",
                            "description": f"Share {share} is accessible without authentication",
                            "service": "smb",
                            "port": str(smb_results.get("port", 445)),
                            "severity": "MEDIUM",
                            "source": "smbclient",
                            "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                        }
                        
                        self.results["vulnerabilities"].append(vulnerability)
                        self.logger.warning(f"Anonymous access to SMB share {share}")
        
        # Check for known vulnerabilities like EternalBlue
        port = smb_results.get("port", 445)
        output_file = self.config.get_output_file(f"smb_vulns_{port}", "txt")
        
        cmd = ["nmap", "--script", "smb-vuln*", "-p", str(port), self.target, "-oN", output_file]
        
        result = run_tool(cmd)
        
        if result["returncode"] == 0:
            # Parse results to identify vulnerabilities
            for line in result["stdout"].splitlines():
                # Search for vulnerability information
                if "VULNERABLE" in line:
                    vuln_match = re.search(r"smb-vuln-([a-zA-Z0-9-]+)", line)
                    if vuln_match:
                        vuln_name = vuln_match.group(1)
                        
                        # Set severity based on vulnerability type
                        severity = "MEDIUM"
                        if "ms17-010" in vuln_name:  # EternalBlue
                            severity = "CRITICAL"
                        
                        vulnerability = {
                            "name": f"SMB Vulnerability: {vuln_name}",
                            "description": f"SMB server vulnerable to {vuln_name}",
                            "service": "smb",
                            "port": str(port),
                            "severity": severity,
                            "source": "nmap",
                            "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                        }
                        
                        self.results["vulnerabilities"].append(vulnerability)
                        self.logger.warning(f"Identified SMB vulnerability: {vuln_name}")
    
    def _perform_basic_bruteforce(self, scan_results):
        """
        Perform basic brute force attempts on identified services
        // ביצוע ניסיונות פריצה בסיסיים לשירותים שזוהו
        
        Args:
            scan_results: Results from previous scanning stages
        """
        self.logger.info(f"Performing basic brute force attempts for {self.target}")
        
        # Try with Hydra, if installed
        if not self._is_tool_available("hydra"):
            self.logger.warning("Hydra tool not found, skipping brute force attempts")
            return
        
        # Try to brute force SSH if identified
        if "enumeration" in scan_results and "ssh" in scan_results["enumeration"]:
            ssh_info = scan_results["enumeration"]["ssh"]
            if "auth_methods" in ssh_info and "password" in ssh_info["auth_methods"]:
                port = ssh_info.get("port", 22)
                
                # Run hydra with a limited list of users and passwords for demonstration
                output_file = self.config.get_output_file(f"hydra_ssh_{port}", "txt")
                
                # Limited brute force attempt with very common users and passwords
                user_list = self.config.wordlist_paths.get("usernames", "")
                pass_list = self.config.wordlist_paths.get("rockyou", "")
                
                if not os.path.exists(user_list) or not os.path.exists(pass_list):
                    self.logger.warning("Suitable wordlists not found for brute force attempt")
                    return
                
                cmd = [
                    "hydra", 
                    "-L", user_list, 
                    "-P", pass_list, 
                    "-f", 
                    "-t", "4",
                    "-o", output_file,
                    f"{self.target}", 
                    "ssh"
                ]
                
                self.logger.debug(f"Attempting to brute force SSH on port {port}")
                
                result = run_tool(cmd, timeout=300)  # Limited runtime
                
                if result["returncode"] == 0:
                    # Check if credentials were found
                    if "password found" in result["stdout"].lower():
                        # Extract the username and password
                        cred_match = re.search(r"login:\s+(\S+)\s+password:\s+(\S+)", result["stdout"])
                        if cred_match:
                            username = cred_match.group(1)
                            password = cred_match.group(2)
                            
                            credential = {
                                "service": "ssh",
                                "port": str(port),
                                "username": username,
                                "password": password,
                                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                            }
                            
                            self.results["credentials"].append(credential)
                            
                            vulnerability = {
                                "name": "Weak SSH Credentials",
                                "description": f"Found weak credentials for SSH service: {username}/{password}",
                                "service": "ssh",
                                "port": str(port),
                                "severity": "HIGH",
                                "source": "hydra",
                                "date_found": time.strftime("%Y-%m-%d %H:%M:%S")
                            }
                            
                            self.results["vulnerabilities"].append(vulnerability)
                            self.logger.warning(f"Found weak SSH credentials: {username}/{password}")
    
    def _find_potential_exploits(self):
        """
        Search for potential exploit mechanisms for identified vulnerabilities
        // חיפוש מנגנוני ניצול פוטנציאליים עבור הפגיעויות שזוהו
        """
        self.logger.info(f"Searching for potential exploits for {self.target}")
        
        # For each vulnerability, try to find an exploit
        for vuln in self.results["vulnerabilities"]:
            vuln_name = vuln["name"]
            
            # Search in searchsploit if installed
            if self._is_tool_available("searchsploit"):
                output_file = self.config.get_output_file(f"searchsploit_{vuln_name.replace(' ', '_')}", "txt")
                
                # Clean the string for safe search
                search_term = re.sub(r'[^a-zA-Z0-9\s-]', '', vuln_name)
                
                cmd = ["searchsploit", "--colour", search_term]
                
                result = run_tool(cmd, output_file=output_file)
                
                if result["returncode"] == 0:
                    # Check if results were found
                    exploit_lines = []
                    for line in result["stdout"].splitlines():
                        if "|" in line and "Exploit Title" not in line:
                            exploit_lines.append(line.strip())
                    
                    if exploit_lines:
                        # Create a list of potential exploits
                        for exploit_line in exploit_lines[:3]:  # Take only first 3 for demonstration
                            exploit_parts = exploit_line.split("|")
                            if len(exploit_parts) >= 2:
                                exploit_title = exploit_parts[0].strip()
                                exploit_path = exploit_parts[1].strip() if len(exploit_parts) > 1 else ""
                                
                                exploit = {
                                    "name": exploit_title,
                                    "path": exploit_path,
                                    "vulnerability": vuln_name,
                                    "service": vuln["service"],
                                    "port": vuln["port"],
                                    "source": "searchsploit"
                                }
                                
                                self.results["exploits"].append(exploit)
                                self.logger.info(f"Found potential exploit: {exploit_title} for {vuln_name}")
        
        # Find exploits for discovered services using the enhanced searchsploit functionality
        if hasattr(self, 'enumeration') and self.enumeration:
            self._find_service_exploits()
        else:
            from redflow.modules.enumeration import Enumeration
            self.enumeration = Enumeration(self.config, self.logger, self.console)
            self._find_service_exploits()
    
    def _find_service_exploits(self):
        """
        Search for exploits for specific services based on version information
        // חיפוש מנגנוני ניצול עבור שירותים ספציפיים בהתבסס על מידע גרסה
        """
        self.logger.info(f"Searching for service-specific exploits for {self.target}")
        
        if not hasattr(self, 'scan_results') or not self.scan_results:
            self.logger.warning("No scan results available for service exploit search")
            return
        
        if "discovered_services" in self.scan_results:
            discovered_services = self.scan_results["discovered_services"]
            
            for service in discovered_services:
                service_name = service.get("name", "").lower()
                product = service.get("product", "").lower()
                version = service.get("version", "")
                
                # Try to find a more specific product name to search for
                search_name = product if product else service_name
                
                # Skip if we don't have enough information
                if not search_name or not version:
                    continue
                
                self.logger.info(f"Searching exploits for {search_name} {version}")
                
                # Use the enhanced searchsploit functionality
                try:
                    search_results = self.enumeration.find_vulnerabilities_with_searchsploit(search_name, version)
                    
                    # Process results
                    if search_results and "vulnerabilities" in search_results:
                        for vuln in search_results["vulnerabilities"]:
                            exploit = {
                                "name": vuln.get("title", "Unknown exploit"),
                                "path": vuln.get("path", ""),
                                "vulnerability": f"{search_name} {version} exploitation",
                                "service": service_name,
                                "port": service.get("port", ""),
                                "source": "searchsploit"
                            }
                            
                            self.results["exploits"].append(exploit)
                            self.logger.info(f"Found potential exploit: {exploit['name']} for {search_name} {version}")
                except Exception as e:
                    self.logger.error(f"Error searching exploits for {search_name} {version}: {str(e)}")
    
    def interactive_exploit_launcher(self):
        """
        Interactive menu for browsing and launching discovered exploits
        // תפריט אינטראקטיבי לעיון והפעלת מנגנוני ניצול שהתגלו
        
        Returns:
            bool: Whether an exploit was successfully executed
        """
        if not self.results["exploits"]:
            self.console.print("[yellow]No potential exploits found to launch.[/yellow]")
            
            # Ask if user wants to search for exploits manually
            self.console.print("[bold]Would you like to search for exploits manually?[/bold] (y/n)")
            response = input("> ").strip().lower()
            
            if response in ["y", "yes"]:
                self.console.print("[bold]Enter service name and version (e.g., vsftpd 2.3.4):[/bold]")
                search_term = input("> ").strip()
                
                if ":" in search_term:
                    service, version = search_term.split(":", 1)
                elif " " in search_term:
                    service, version = search_term.split(" ", 1)
                else:
                    service = search_term
                    version = ""
                
                if hasattr(self, 'enumeration') and self.enumeration:
                    return self.enumeration.interactive_exploit_menu("manual", service, version, self.target)
                else:
                    from redflow.modules.enumeration import Enumeration
                    self.enumeration = Enumeration(self.config, self.logger, self.console)
                    return self.enumeration.interactive_exploit_menu("manual", service, version, self.target)
            
            return False
        
        # Display available exploits
        self.console.print("\n[bold green]Available Exploits:[/bold green]")
        
        exploit_table = Table(title="Potential Exploits")
        exploit_table.add_column("#", style="cyan")
        exploit_table.add_column("Service", style="cyan")
        exploit_table.add_column("Port", style="cyan")
        exploit_table.add_column("Vulnerability", style="yellow")
        exploit_table.add_column("Exploit", style="green")
        exploit_table.add_column("Path", style="magenta")
        
        for i, exploit in enumerate(self.results["exploits"], 1):
            exploit_table.add_row(
                str(i),
                exploit.get("service", "unknown"),
                str(exploit.get("port", "")),
                exploit.get("vulnerability", ""),
                exploit.get("name", ""),
                exploit.get("path", "")
            )
        
        self.console.print(exploit_table)
        
        # Ask user to select an exploit
        self.console.print("\n[bold]Enter the number of the exploit to use (or 'q' to quit):[/bold]")
        selection = input("> ").strip().lower()
        
        if selection == "q":
            return False
        
        try:
            idx = int(selection)
            if 1 <= idx <= len(self.results["exploits"]):
                selected = self.results["exploits"][idx-1]
                exploit_path = selected.get("path", "")
                
                if not exploit_path:
                    self.console.print("[red]No exploit path available for this selection.[/red]")
                    return False
                
                # Use the prepare_exploit function from enumeration
                if hasattr(self, 'enumeration') and self.enumeration:
                    exploit_info = self.enumeration.prepare_exploit(exploit_path, self.target)
                    
                    if exploit_info["success"]:
                        self.enumeration.display_exploit_instructions(exploit_info, self.target)
                        return True
                    else:
                        self.console.print(f"[red]Failed to prepare exploit: {exploit_info.get('error', 'Unknown error')}[/red]")
                else:
                    from redflow.modules.enumeration import Enumeration
                    self.enumeration = Enumeration(self.config, self.logger, self.console)
                    exploit_info = self.enumeration.prepare_exploit(exploit_path, self.target)
                    
                    if exploit_info["success"]:
                        self.enumeration.display_exploit_instructions(exploit_info, self.target)
                        return True
                    else:
                        self.console.print(f"[red]Failed to prepare exploit: {exploit_info.get('error', 'Unknown error')}[/red]")
            else:
                self.console.print("[red]Invalid selection.[/red]")
        except ValueError:
            self.console.print("[red]Invalid input. Please enter a number.[/red]")
        
        return False
    
    def _is_tool_available(self, tool_name):
        """
        Check if a tool is available in the system
        // בדיקה האם כלי זמין במערכת
        
        Args:
            tool_name: Name of the tool to check
            
        Returns:
            Boolean: Whether the tool is available
        """
        return shutil.which(tool_name) is not None if 'shutil' in globals() else os.system(f"which {tool_name} > /dev/null") == 0
    
    def _show_results_summary(self):
        """
        Display exploitation results summary
        // הצגת סיכום תוצאות הניצול
        """
        self.console.print("\n[bold green]Vulnerability Analysis Summary:[/bold green]")
        
        # Display vulnerabilities
        if self.results["vulnerabilities"]:
            vuln_table = Table(title="Identified Vulnerabilities")
            vuln_table.add_column("Service", style="cyan")
            vuln_table.add_column("Port", style="cyan")
            vuln_table.add_column("Vulnerability", style="red")
            vuln_table.add_column("Severity", style="yellow")
            
            for vuln in self.results["vulnerabilities"]:
                severity_style = "yellow"
                if vuln["severity"] == "HIGH":
                    severity_style = "red"
                elif vuln["severity"] == "CRITICAL":
                    severity_style = "red bold"
                
                vuln_table.add_row(
                    vuln["service"],
                    vuln["port"],
                    vuln["name"],
                    f"[{severity_style}]{vuln['severity']}[/{severity_style}]"
                )
            
            self.console.print(vuln_table)
        else:
            self.console.print("[yellow]No vulnerabilities identified[/yellow]")
        
        # Display credentials
        if self.results["credentials"]:
            cred_table = Table(title="Exposed Credentials")
            cred_table.add_column("Service", style="cyan")
            cred_table.add_column("Port", style="cyan")
            cred_table.add_column("Username", style="green")
            cred_table.add_column("Password", style="red")
            
            for cred in self.results["credentials"]:
                cred_table.add_row(
                    cred["service"],
                    cred["port"],
                    cred["username"],
                    cred["password"]
                )
            
            self.console.print(cred_table)
        
        # Display exploits
        if self.results["exploits"]:
            exploit_table = Table(title="Potential Exploits")
            exploit_table.add_column("Vulnerability", style="yellow")
            exploit_table.add_column("Exploit Name", style="green")
            exploit_table.add_column("Location", style="cyan")
            
            for exploit in self.results["exploits"]:
                exploit_table.add_row(
                    exploit["vulnerability"],
                    exploit["name"],
                    exploit["path"]
                )
            
            self.console.print(exploit_table)
        
        self.console.print("")  # Extra space 